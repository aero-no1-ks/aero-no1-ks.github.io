(function() {
  (function(global) {
    var module = global.noise = {};
    function Grad(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    Grad.prototype.dot2 = function(x, y) {
      return this.x * x + this.y * y
    }
    Grad.prototype.dot3 = function(x, y, z) {
      return this.x * x + this.y * y + this.z * z
    }
    var grad3 = [new Grad(1,1,0), new Grad(-1,1,0), new Grad(1,-1,0), new Grad(-1,-1,0), new Grad(1,0,1), new Grad(-1,0,1), new Grad(1,0,-1), new Grad(-1,0,-1), new Grad(0,1,1), new Grad(0,-1,1), new Grad(0,1,-1), new Grad(0,-1,-1)];
    var p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
    var perm = new Array(512);
    var gradP = new Array(512);
    module.seed = function(seed) {
      if(seed > 0 && seed < 1) {
        seed *= 65536
      }
      seed = Math.floor(seed);
      if(seed < 256) {
        seed |= seed << 8
      }
      for(var i = 0; i < 256; i++) {
        var v;
        if(i & 1) {
          v = p[i] ^ (seed & 255)
        } else {
          v = p[i] ^ ((seed >> 8) & 255)
        }
        perm[i] = perm[i + 256] = v;
        gradP[i] = gradP[i + 256] = grad3[v % 12]
      }
    }
    ;
    module.seed(0);
    var F2 = 0.5 * (Math.sqrt(3) - 1);
    var G2 = (3 - Math.sqrt(3)) / 6;
    var F3 = 1 / 3;
    var G3 = 1 / 6;
    module.simplex2 = function(xin, yin) {
      var n0, n1, n2;
      var s = (xin + yin) * F2;
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var t = (i + j) * G2;
      var x0 = xin - i + t;
      var y0 = yin - j + t;
      var i1, j1;
      if(x0 > y0) {
        i1 = 1;
        j1 = 0
      } else {
        i1 = 0;
        j1 = 1
      }
      var x1 = x0 - i1 + G2;
      var y1 = y0 - j1 + G2;
      var x2 = x0 - 1 + 2 * G2;
      var y2 = y0 - 1 + 2 * G2;
      i &= 255;
      j &= 255;
      var gi0 = gradP[i + perm[j]];
      var gi1 = gradP[i + i1 + perm[j + j1]];
      var gi2 = gradP[i + 1 + perm[j + 1]];
      var t0 = 0.5 - x0 * x0 - y0 * y0;
      if(t0 < 0) {
        n0 = 0
      } else {
        t0 *= t0;
        n0 = t0 * t0 * gi0.dot2(x0, y0)
      }
      var t1 = 0.5 - x1 * x1 - y1 * y1;
      if(t1 < 0) {
        n1 = 0
      } else {
        t1 *= t1;
        n1 = t1 * t1 * gi1.dot2(x1, y1)
      }
      var t2 = 0.5 - x2 * x2 - y2 * y2;
      if(t2 < 0) {
        n2 = 0
      } else {
        t2 *= t2;
        n2 = t2 * t2 * gi2.dot2(x2, y2)
      }
      return 70 * (n0 + n1 + n2)
    }
    ;
    module.simplex3 = function(xin, yin, zin) {
      var n0, n1, n2, n3;
      var s = (xin + yin + zin) * F3;
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var k = Math.floor(zin + s);
      var t = (i + j + k) * G3;
      var x0 = xin - i + t;
      var y0 = yin - j + t;
      var z0 = zin - k + t;
      var i1, j1, k1;
      var i2, j2, k2;
      if(x0 >= y0) {
        if(y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0
        } else {
          if(x0 >= z0) {
            i1 = 1;
            j1 = 0;
            k1 = 0;
            i2 = 1;
            j2 = 0;
            k2 = 1
          } else {
            i1 = 0;
            j1 = 0;
            k1 = 1;
            i2 = 1;
            j2 = 0;
            k2 = 1
          }
        }
      } else {
        if(y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 0;
          j2 = 1;
          k2 = 1
        } else {
          if(x0 < z0) {
            i1 = 0;
            j1 = 1;
            k1 = 0;
            i2 = 0;
            j2 = 1;
            k2 = 1
          } else {
            i1 = 0;
            j1 = 1;
            k1 = 0;
            i2 = 1;
            j2 = 1;
            k2 = 0
          }
        }
      }
      var x1 = x0 - i1 + G3;
      var y1 = y0 - j1 + G3;
      var z1 = z0 - k1 + G3;
      var x2 = x0 - i2 + 2 * G3;
      var y2 = y0 - j2 + 2 * G3;
      var z2 = z0 - k2 + 2 * G3;
      var x3 = x0 - 1 + 3 * G3;
      var y3 = y0 - 1 + 3 * G3;
      var z3 = z0 - 1 + 3 * G3;
      i &= 255;
      j &= 255;
      k &= 255;
      var gi0 = gradP[i + perm[j + perm[k]]];
      var gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];
      var gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];
      var gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]];
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if(t0 < 0) {
        n0 = 0
      } else {
        t0 *= t0;
        n0 = t0 * t0 * gi0.dot3(x0, y0, z0)
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if(t1 < 0) {
        n1 = 0
      } else {
        t1 *= t1;
        n1 = t1 * t1 * gi1.dot3(x1, y1, z1)
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if(t2 < 0) {
        n2 = 0
      } else {
        t2 *= t2;
        n2 = t2 * t2 * gi2.dot3(x2, y2, z2)
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if(t3 < 0) {
        n3 = 0
      } else {
        t3 *= t3;
        n3 = t3 * t3 * gi3.dot3(x3, y3, z3)
      }
      return 32 * (n0 + n1 + n2 + n3)
    }
    ;
    function fade(t) {
      return t * t * t * (t * (t * 6 - 15) + 10)
    }
    function lerp(a, b, t) {
      return (1 - t) * a + t * b
    }
    module.perlin2 = function(x, y) {
      var X = Math.floor(x)
      , Y = Math.floor(y);
      x = x - X;
      y = y - Y;
      X = X & 255;
      Y = Y & 255;
      var n00 = gradP[X + perm[Y]].dot2(x, y);
      var n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);
      var n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);
      var n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);
      var u = fade(x);
      return lerp(lerp(n00, n10, u), lerp(n01, n11, u), fade(y))
    }
    ;
    module.perlin3 = function(x, y, z) {
      var X = Math.floor(x)
      , Y = Math.floor(y)
      , Z = Math.floor(z);
      x = x - X;
      y = y - Y;
      z = z - Z;
      X = X & 255;
      Y = Y & 255;
      Z = Z & 255;
      var n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);
      var n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);
      var n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);
      var n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);
      var n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);
      var n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);
      var n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);
      var n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(x - 1, y - 1, z - 1);
      var u = fade(x);
      var v = fade(y);
      var w = fade(z);
      return lerp(lerp(lerp(n000, n100, u), lerp(n001, n101, u), w), lerp(lerp(n010, n110, u), lerp(n011, n111, u), w), v)
    }
  }
  )(this);
  function Igloo(gl, options) {
    var canvas;
    if(gl instanceof HTMLCanvasElement) {
      canvas = gl;
      gl = Igloo.getContext(gl, options)
    } else {
      canvas = gl.canvas
    }
    this.gl = gl;
    this.canvas = canvas;
    this.defaultFramebuffer = new Igloo.Framebuffer(gl,null)
  }
  Igloo.QUAD2 = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
  Igloo.fetch = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, false);
    if(callback != null) {
      xhr.onload = function() {
        callback(xhr.responseText)
      }
    }
    xhr.send();
    return xhr.responseText
  }
  ;
  Igloo.getContext = function(canvas, options, noerror) {
    var gl;
    try {
      gl = canvas.getContext("webgl", options || {}) || canvas.getContext("experimental-webgl", options || {})
    } catch (e) {
      gl = null
    }
    if(gl == null && !noerror) {
      throw new Error("Could not create WebGL context.")
    } else {
      return gl
    }
  }
  ;
  Igloo.looksLikeURL = function(string) {
    return /^[\w+:\/\/]/.exec(string) != null
  }
  ;
  Igloo.isArray = function(object) {
    var name = Object.prototype.toString.apply(object, [])
    , re = / (Float(32|64)|Int(16|32|8)|Uint(16|32|8(Clamped)?))?Array]$/;
    return re.exec(name) != null
  }
  ;
  Igloo.prototype.program = function(vertex, fragment, transform) {
    if(Igloo.looksLikeURL(vertex)) {
      vertex = Igloo.fetch(vertex)
    }
    if(Igloo.looksLikeURL(fragment)) {
      fragment = Igloo.fetch(fragment)
    }
    if(transform != null) {
      vertex = transform(vertex);
      fragment = transform(fragment)
    }
    return new Igloo.Program(this.gl,vertex,fragment)
  }
  ;
  Igloo.prototype.array = function(data, usage) {
    var gl = this.gl
    , buffer = new Igloo.Buffer(gl,gl.ARRAY_BUFFER);
    if(data != null) {
      buffer.update(data, usage == null ? gl.STATIC_DRAW : usage)
    }
    return buffer
  }
  ;
  Igloo.prototype.elements = function(data, usage) {
    var gl = this.gl
    , buffer = new Igloo.Buffer(gl,gl.ELEMENT_ARRAY_BUFFER);
    if(data != null) {
      buffer.update(data, usage == null ? gl.STATIC_DRAW : usage)
    }
    return buffer
  }
  ;
  Igloo.prototype.texture = function(source, format, wrap, filter) {
    var texture = new Igloo.Texture(this.gl,format,wrap,filter);
    if(source != null) {
      texture.set(source)
    }
    return texture
  }
  ;
  Igloo.prototype.framebuffer = function(texture) {
    var framebuffer = new Igloo.Framebuffer(this.gl);
    if(texture != null) {
      framebuffer.attach(texture)
    }
    return framebuffer
  }
  ;
  Igloo.Program = function(gl, vertex, fragment) {
    this.gl = gl;
    var p = this.program = gl.createProgram();
    gl.attachShader(p, this.makeShader(gl.VERTEX_SHADER, vertex));
    gl.attachShader(p, this.makeShader(gl.FRAGMENT_SHADER, fragment));
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)) {
      throw new Error(gl.getProgramInfoLog(p))
    }
    this.vars = {}
  }
  ;
  Igloo.Program.prototype.makeShader = function(type, source) {
    var gl = this.gl;
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if(gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      return shader
    } else {
      throw new Error(gl.getShaderInfoLog(shader))
    }
  }
  ;
  Igloo.Program.prototype.use = function() {
    this.gl.useProgram(this.program);
    return this
  }
  ;
  Igloo.Program.prototype.uniform = function(name, value, i) {
    if(value == null) {
      this.vars[name] = this.gl.getUniformLocation(this.program, name)
    } else {
      if(this.vars[name] == null) {
        this.uniform(name)
      }
      var v = this.vars[name];
      if(Igloo.isArray(value)) {
        var method = "uniform" + value.length + (i ? "i" : "f") + "v";
        this.gl[method](v, value)
      } else {
        if(typeof value === "number" || typeof value === "boolean") {
          if(i) {
            this.gl.uniform1i(v, value)
          } else {
            this.gl.uniform1f(v, value)
          }
        } else {
          throw new Error("Invalid uniform value: " + value)
        }
      }
    }
    return this
  }
  ;
  Igloo.Program.prototype.matrix = function(name, matrix, transpose) {
    if(this.vars[name] == null) {
      this.uniform(name)
    }
    var method = "uniformMatrix" + Math.sqrt(matrix.length) + "fv";
    this.gl[method](this.vars[name], Boolean(transpose), matrix);
    return this
  }
  ;
  Igloo.Program.prototype.uniformi = function(name, value) {
    return this.uniform(name, value, true)
  }
  ;
  Igloo.Program.prototype.attrib = function(name, value, size, stride) {
    var gl = this.gl;
    if(value == null) {
      this.vars[name] = gl.getAttribLocation(this.program, name)
    } else {
      if(this.vars[name] == null) {
        this.attrib(name)
      }
      value.bind();
      gl.enableVertexAttribArray(this.vars[name]);
      gl.vertexAttribPointer(this.vars[name], size, gl.FLOAT, false, stride == null ? 0 : stride, 0)
    }
    return this
  }
  ;
  Igloo.Program.prototype.draw = function(mode, count, type) {
    var gl = this.gl;
    if(type == null) {
      gl.drawArrays(mode, 0, count)
    } else {
      gl.drawElements(mode, count, type, 0)
    }
    if(gl.getError() !== gl.NO_ERROR) {
      throw new Error("WebGL rendering error")
    }
    return this
  }
  ;
  Igloo.Program.prototype.disable = function() {
    for(var attrib in this.vars) {
      var location = this.vars[attrib];
      if(this.vars.hasOwnProperty(attrib)) {
        if(typeof location === "number") {
          this.gl.disableVertexAttribArray(location)
        }
      }
    }
    return this
  }
  ;
  Igloo.Buffer = function(gl, target) {
    this.gl = gl;
    this.buffer = gl.createBuffer();
    this.target = (target == null ? gl.ARRAY_BUFFER : target);
    this.size = -1
  }
  ;
  Igloo.Buffer.prototype.bind = function() {
    this.gl.bindBuffer(this.target, this.buffer);
    return this
  }
  ;
  Igloo.Buffer.prototype.update = function(data, usage) {
    var gl = this.gl;
    if(data instanceof Array) {
      data = new Float32Array(data)
    }
    usage = usage == null ? gl.DYNAMIC_DRAW : usage;
    this.bind();
    if(this.size !== data.byteLength) {
      gl.bufferData(this.target, data, usage);
      this.size = data.byteLength
    } else {
      gl.bufferSubData(this.target, 0, data)
    }
    return this
  }
  ;
  Igloo.Texture = function(gl, format, wrap, filter) {
    this.gl = gl;
    var texture = this.texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    wrap = wrap == null ? gl.CLAMP_TO_EDGE : wrap;
    filter = filter == null ? gl.LINEAR : filter;
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    this.format = format = format == null ? gl.RGBA : format
  }
  ;
  Igloo.Texture.prototype.bind = function(unit) {
    var gl = this.gl;
    if(unit != null) {
      gl.activeTexture(gl.TEXTURE0 + unit)
    }
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    return this
  }
  ;
  Igloo.Texture.prototype.blank = function(width, height) {
    var gl = this.gl;
    this.bind();
    gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, gl.UNSIGNED_BYTE, null);
    return this
  }
  ;
  Igloo.Texture.prototype.set = function(source, width, height) {
    var gl = this.gl;
    this.bind();
    if(source instanceof Array) {
      source = new Uint8Array(source)
    }
    if(width != null || height != null) {
      gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, gl.UNSIGNED_BYTE, source)
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, gl.UNSIGNED_BYTE, source)
    }
    return this
  }
  ;
  Igloo.Texture.prototype.subset = function(source, xoff, yoff, width, height) {
    var gl = this.gl;
    this.bind();
    if(source instanceof Array) {
      source = new Uint8Array(source)
    }
    if(width != null || height != null) {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, xoff, yoff, width, height, this.format, gl.UNSIGNED_BYTE, source)
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, xoff, yoff, this.format, gl.UNSIGNED_BYTE, source)
    }
    return this
  }
  ;
  Igloo.Texture.prototype.copy = function(x, y, width, height) {
    var gl = this.gl;
    gl.copyTexImage2D(gl.TEXTURE_2D, 0, this.format, x, y, width, height, 0);
    return this
  }
  ;
  Igloo.Framebuffer = function(gl, framebuffer) {
    this.gl = gl;
    this.framebuffer = arguments.length == 2 ? framebuffer : gl.createFramebuffer();
    this.renderbuffer = null
  }
  ;
  Igloo.Framebuffer.prototype.bind = function() {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
    return this
  }
  ;
  Igloo.Framebuffer.prototype.unbind = function() {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    return this
  }
  ;
  Igloo.Framebuffer.prototype.attach = function(texture) {
    var gl = this.gl;
    this.bind();
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture.texture, 0);
    return this
  }
  ;
  Igloo.Framebuffer.prototype.attachDepth = function(width, height) {
    var gl = this.gl;
    this.bind();
    if(this.renderbuffer == null) {
      this.renderbuffer = gl.createRenderbuffer();
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderbuffer)
    }
    return this
  }
  ;
  (function() {
    var env = {};
    env.isIpad = (/ipad/gi).test(navigator.appVersion);
    env.isHiRes = window.devicePixelRatio && window.devicePixelRatio > 1;
    env.isIphone = (/iphone/gi).test(navigator.appVersion);
    env.isAndroid = (/android/gi).test(navigator.appVersion);
    env.isTouch = env.isIphone || env.isIpad || env.isAndroid;
    env.isFirefox = (/Firefox/.test(navigator.userAgent));
    env.isMSIE = (/MSIE/.test(navigator.userAgent));
    env.isMobile = env.isIphone || env.isAndroid;
    env.isSafari = /^((?!chrome).)*safari/i.test(navigator.userAgent);
    env.LAUNCH_EVENT = env.isTouch ? "touchstart" : "mousedown";
    env.MOVE_EVENT = env.isTouch ? "touchmove" : "mousemove";
    env.END_EVENT = env.isTouch ? "touchend" : "mouseup";
    if(window.F) {
      window.F.env = env
    } else {
      window.F = {
        env: env
      }
    }
    (function() {
      var lastTime = 0;
      var vendors = ["webkit", "moz"];
      for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"]
      }
      if(!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(callback, element) {
          var currTime = new Date().getTime();
          var timeToCall = Math.max(0, 16 - (currTime - lastTime));
          var id = window.setTimeout(function() {
            callback(currTime + timeToCall)
          }, timeToCall);
          lastTime = currTime + timeToCall;
          return id
        }
      }
      if(!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(id) {
          clearTimeout(id)
        }
      }
    }
    )();
    (function() {
      try {
        if(typeof console == "undefined") {
          console = {
            log: function() {}
          }
        } else {
          if(typeof console.log == "undefined") {
            console.log = function() {}
          }
        }
      } catch (err) {}
    }
    )();
    /*!
 * jQuery scrollbarWidth - v0.2 - 2/11/2009
 * http://benalman.com/projects/jquery-misc-plugins/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
    if(jQuery) {
      (function($, undefined, width) {
        $.scrollbarWidth = function() {
          var parent, child;
          if(width === undefined) {
            parent = $('<div style="width:50px;height:50px;overflow:auto"><div/></div>').appendTo("body");
            child = parent.children();
            width = child.innerWidth() - child.height(99).innerWidth();
            parent.remove()
          }
          return width
        }
      }
      )(jQuery)
    }
  }
  )();
  "use strict";
  (function() {
    if(!window.F) {
      window.F = {}
    }
    function dispatchEvent(type, params) {
      var callbacks = this.listeners[type];
      if(callbacks) {
        for(var i = 0, L = callbacks.length; i < L; i++) {
          callbacks[i](params)
        }
      }
    }
    function addEventListener(type, callback) {
      if(!callback) {
        console.log("Missing callback for ", type)
      }
      var callbacks = this.listeners[type];
      if(callbacks && callbacks.indexOf(callback) < 0) {
        callbacks.push(callback)
      } else {
        this.listeners[type] = [callback]
      }
    }
    function removeEventListener(type, callback) {
      var callbacks = this.listeners[type]
      , index = callbacks ? callbacks.indexOf(callback) : -1
      , L = callbacks.length;
      if(index == 0) {
        callbacks.shift();
        this.listeners[type] = callbacks
      } else {
        if(index > 0) {
          callbacks.splice(index, 1);
          this.listeners[type] = callbacks
        }
      }
    }
    window.F.eventify = function(obj) {
      obj.listeners = {};
      obj.addEventListener = addEventListener;
      obj.removeEventListener = removeEventListener;
      obj.dispatchEvent = dispatchEvent;
      obj.listen = addEventListener;
      obj.ignore = removeEventListener;
      obj.announce = dispatchEvent
    }
  }
  )();
  "use strict";
  (function() {
    if(!window.F) {
      window.F = {}
    }
    function inheritFrom(base, child) {
      var defined = {};
      for(var e in child.prototype) {
        defined[e] = child.prototype[e]
      }
      child.prototype = new base();
      child.prototype.constructor = child;
      for(var e in defined) {
        child.prototype[e] = defined[e]
      }
    }
    function isEmptyObject(obj) {
      if(!obj) {
        return true
      }
      var names = Object.getOwnPropertyNames(obj)
      , empty = names.length == 0;
      return empty
    }
    function objectUpsert(obj, key) {
      var val = obj[key];
      if(undefined === val) {
        val = {};
        obj[key] = val
      }
      return val
    }
    if(!Object.getOwnPropertyNames) {
      isEmptyObject = function(obj) {
        for(var e in obj) {
          return false
        }
        return true
      }
    }
    window.F.inheritFrom = inheritFrom;
    window.F.isEmptyObject = isEmptyObject;
    window.F.objectUpsert = objectUpsert
  }
  )();
  "use strict";
  (function() {
    if(!window.F) {
      window.F = {}
    }
    var ATTRACTION = 0.2;
    var DAMPING = 0.5;
    var EPSILON = 0.0001;
    function SoftFloat() {
      this.value = 0;
      this.velocity = 0;
      this.acceleration = 0;
      this.damping = DAMPING;
      this.attraction = ATTRACTION;
      this.epsilon = EPSILON;
      this.atTarget = true;
      if(arguments.length === 1) {
        this.value = arguments[0]
      } else {
        if(arguments.length === 3) {
          this.value = arguments[0];
          this.damping = arguments[1];
          this.attraction = arguments[2]
        }
      }
      this.target = this.value
    }
    SoftFloat.prototype.set = function(v) {
      this.value = v;
      this.atTarget = true
    }
    ;
    SoftFloat.prototype.pin = function() {
      if(arguments.length == 1) {
        this.target = arguments[0]
      }
      this.value = this.target;
      this.atTarget = true
    }
    ;
    SoftFloat.prototype.get = function() {
      return this.value
    }
    ;
    SoftFloat.prototype.getInt = function() {
      return Math.floor(this.value)
    }
    ;
    SoftFloat.prototype.update = function() {
      if(!this.atTarget) {
        this.acceleration += this.attraction * (this.target - this.value);
        this.velocity = (this.velocity + this.acceleration) * this.damping;
        this.value += this.velocity;
        this.acceleration = 0;
        if(Math.abs(this.velocity) > this.epsilon) {
          return true
        }
        this.value = this.target;
        this.atTarget = true
      }
      return false
    }
    ;
    SoftFloat.prototype.setTarget = function(t) {
      this.atTarget = false;
      this.target = t
    }
    ;
    SoftFloat.prototype.getTarget = function() {
      return this.target
    }
    ;
    SoftFloat.prototype.isSet = function() {
      return this.getTarget() == 1
    }
    ;
    SoftFloat.prototype.toggle = function() {
      this.setTarget(this.getTarget() == 1 ? 0 : 1)
    }
    ;
    window.F.SoftFloat = SoftFloat
  }
  )();
  (function() {
    var abs = Math.abs
    , round = Math.round;
    function hue2rgb(p, q, t) {
      if(t < 1 / 6) {
        return p + (q - p) * 6 * t
      }
      if(t < 1 / 2) {
        return q
      }
      if(t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6
      }
      return p
    }
    function hsl2rgb(hsl) {
      var r, g, b, h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100;
      if(s == 0) {
        r = g = b = l
      } else {
        while (h < 0) {
          h += 1
        }
        while (h > 1) {
          h -= 1
        }
        var chroma = (1 - abs(2 * l - 1)) * s;
        var x = chroma * (1 - abs((h * 6) % 2 - 1));
        var m = l - chroma * 0.5;
        if(h < 1 / 6) {
          r = chroma;
          g = x;
          b = 0
        } else {
          if(h < 2 / 6) {
            r = x;
            g = chroma;
            b = 0
          } else {
            if(h < 3 / 6) {
              r = 0;
              g = chroma;
              b = x
            } else {
              if(h < 4 / 6) {
                r = 0;
                g = x;
                b = chroma
              } else {
                if(h < 5 / 6) {
                  r = x;
                  g = 0;
                  b = chroma
                } else {
                  r = chroma;
                  g = 0;
                  b = x
                }
              }
            }
          }
        }
        r += m;
        g += m;
        b += m
      }
      return [round(r * 255), round(g * 255), round(b * 255)]
    }
    function rgb2hsl(rgb) {
      var red = 1 * rgb[0] / 255;
      var green = 1 * rgb[1] / 255;
      var blue = 1 * rgb[2] / 255;
      var min = red < green ? red : green;
      min = min < blue ? min : blue;
      var max = red > green ? red : green;
      max = max > blue ? max : blue;
      var l = 50 * (max + min);
      var h, s;
      if(max == min) {
        h = 0;
        s = 0
      } else {
        var maxMinDiff = max - min;
        if(l <= 50) {
          s = 100 * maxMinDiff / (max + min)
        } else {
          s = 100 * maxMinDiff / (2 - max - min)
        }
        if(max == red) {
          h = (60 * ((green - blue) / maxMinDiff) + 360) % 360
        } else {
          if(max == green) {
            h = 60 * ((blue - red) / maxMinDiff) + 120
          } else {
            if(max == blue) {
              h = 60 * ((red - green) / maxMinDiff) + 240
            }
          }
        }
      }
      return [h, s, l]
    }
    function lerpColor(c1, c2, progress) {
      if(progress <= 0) {
        return c1.slice(0)
      }
      if(progress >= 1) {
        return c2.slice(0)
      }
      var result = [];
      for(var i = 0, L = c1.length; i < L; i++) {
        result[i] = c1[i] + (c2[i] - c1[i]) * progress
      }
      return result
    }
    function test() {
      function rgb2hslAndBack(rgb) {
        var hsl = rgb2hsl(rgb);
        var backAgain = hsl2rgb(hsl);
        var success = true;
        for(var i = 0, L = backAgain.length; i < L; i++) {
          backAgain[i] = Math.round(backAgain[i]);
          if(backAgain[i] != rgb[i]) {
            success = false
          }
        }
        console.log(rgb, backAgain, success, hsl)
      }
      rgb2hslAndBack([0, 0, 0]);
      rgb2hslAndBack([255, 255, 255]);
      rgb2hslAndBack([255, 0, 0]);
      rgb2hslAndBack([0, 255, 0]);
      rgb2hslAndBack([0, 0, 255]);
      rgb2hslAndBack([255, 0, 1]);
      rgb2hslAndBack([255, 255, 0]);
      rgb2hslAndBack([255, 255, 100]);
      rgb2hslAndBack([200, 200, 200]);
      rgb2hslAndBack([100, 100, 100]);
      rgb2hslAndBack([0, 128, 255]);
      rgb2hslAndBack([128, 128, 255]);
      rgb2hslAndBack([100, 150, 200])
    }
    if(!window.F) {
      window.F = {}
    }
    window.F.color = {
      hsl2rgb: hsl2rgb,
      rgb2hsl: rgb2hsl,
      lerpColor: lerpColor
    }
  }
  )();
  "use strict";
  (function() {
    if(!window.F) {
      window.F = {}
    }
    var log = Math.log
    , floor = Math.floor
    , ceil = Math.ceil
    , max = Math.max
    , pow = Math.pow;
    function NumberLabeler(minValue, maxValue, ticks) {
      this.valueMin = minValue;
      this.valueMax = maxValue;
      var range = nicenum(maxValue - minValue, false);
      var d = nicenum(range / (ticks - 1), true);
      var graphMin = floor(minValue / d) * d;
      var graphMax = ceil(maxValue / d) * d;
      var nfrac = floor(max(-floor(log10(d)), 0));
      this.value = [];
      this.label = [];
      for(var x = graphMin; x < graphMax + 0.5 * d; x += d) {
        this.value.push(x);
        this.label.push(x.toFixed(nfrac))
      }
      this.tickCount = this.value.length
    }
    function log10(num) {
      return log(num) / log(10)
    }
    function nicenum(x, round) {
      var expv = floor(log10(x));
      var f = x / pow(10, expv);
      var nf;
      if(round) {
        if(f < 1.5) {
          nf = 1
        } else {
          if(f < 3) {
            nf = 2
          } else {
            if(f < 6) {
              nf = 4
            } else {
              nf = 10
            }
          }
        }
      } else {
        if(f <= 1) {
          nf = 1
        } else {
          if(f <= 2) {
            nf = 2
          } else {
            if(f <= 4) {
              nf = 4
            } else {
              nf = 10
            }
          }
        }
      }
      return nf * pow(10, expv)
    }
    function commify(what) {
      return String(what).replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,")
    }
    NumberLabeler.nicenum = nicenum;
    NumberLabeler.commify = commify;
    window.F.NumberLabeler = NumberLabeler
  }
  )();
  "use strict";
  (function(app) {
    var constants = {
      APP_LAUNCH_EVENT: "app_launch_event",
      DOM_READY_EVENT: "dom_ready_event",
      INTRO_COMPLETE_EVENT: "intro_complete_event",
      PARTICLES_READY_EVENT: "particles_ready_event",
      RESIZE_EVENT: "resize_event",
      ZOOM_PAN_EVENT: "zoom_pan_event",
      ZOOM_RESET_EVENT: "zoom_reset_event",
      BOX_FOCUS_EVENT: "box_focus_event",
      TIME_UPDATE_EVENT: "time_update_event",
      PLAYBACK_EVENT: "playback_event",
      NODES_INITIALIZED_EVENT: "nodes_initialized_event",
      DATA_LOAD_EVENT: "data_load_event",
      LEGEND_SPEED_EVENT: "legend_speed_event",
      LOOPER_CONTROL_EVENT: "looper_control_event",
      GL_STATUS_EVENT: "gl_status_event",
      SELECT_EVENT: "select_event",
      SHARE_CONTROL_EVENT: "share_control_event",
      HEX_ANGLES: [],
      HISTOGRAM_MINUTES_PER_BUCKET: 20,
      GROUP_COUNT: 4,
      GROUP_NAMES: "Practice,Patient,Orders,Payer".split(","),
      SUBGROUP_LABELS: "Practice Encounter,Practice to Patient,Practice to Orders,Practice to Payer".split(","),
      GROUP_COLORS: [[89, 44, 129], [222, 137, 10], [0, 97, 150], [122, 152, 27], [134, 51, 117]],
      GROUP_LERP_COLORS: [[133, 51, 117], [255, 219, 0], [0, 216, 255], [190, 253, 0], [231, 0, 196], ],
      PATH_TYPES: {
        BEZIER: 1,
        SUPER_INTRA: 2,
        SUPER_OUTER: 3,
        INTRA: 4,
        OUTER: 5
      },
      INNER_RING_MARGIN_MIN: 40,
      INNER_RING_MARGIN_RANGE: 20,
      RING_MARGIN_COEFFICIENT: 1.6,
      RING_MARGIN_MIN: 50,
      ARC_EVENT_MARGIN: 24,
      PRACTICE_EVENT_MARGIN: 6,
      INTRO_RING_MARGIN_MIN: 80,
      INTRO_NODE_SIZE: 3,
      EVENT_MIN_SIZE: 2,
      PRACTICE_EVENT_MIN_SIZE: 4,
      EVENT_SIZE_RANGE: 0.5,
      PRACTICE_EVENT_SIZE_RANGE: 1,
      EVENT_LAYOUT_MIN_SIZE: 6,
      PRACTICE_EVENT_LAYOUT_MIN_SIZE: 6,
      EVENT_LAYOUT_SIZE_RANGE: 6.5,
      PRACTICE_EVENT_LAYOUT_SIZE_RANGE: 14,
      MAX_EVENT_PARTICLE_COUNT: 500,
      MAX_LERPER_COUNT: 90000,
      PARTICLE_ALPHA: 0.45,
      PARTICLE_HIGHLIGHT_ALPHA: 0.9,
      PARTICLE_PUSHBACK_ALPHA: 0.045,
      PARTICLE_OFFSET_RANGE: 6,
      PARTICLE_VELOCITY_ROOT: 0.8,
      PARTICLE_VELOCITY_RANGE: 0.8,
      PARTICLE_VELOCITY_MOD: 0.15,
      PARTICLE_SCATTER_BASE: 0.05,
      PARTICLE_SCATTER_RANGE: 0.15,
      PARTICLE_SCATTER_LIMIT: 1,
      PARTICLE_WEIGHT_BASE: 1.1,
      PARTICLE_WEIGHT_DENOMINATOR_BASE: 1.9,
      PARTICLE_WEIGHT_SCALE: 2.7,
      PARTICLE_WEIGHT_POWER: 0.7,
      MIN_PARTICLE_WEIGHT: 0.1,
      MAX_PARTICLE_WEIGHT: 0.8,
      PATH_STOP_COUNT: 18,
      OUTSIDE_PATH_STOP_COUNT: 18,
      TRAVEL_PIXELS: 7,
      RESET_ZOOM_PAN: 1,
      ZOOM_IN: 2,
      ZOOM_OUT: 3,
      DEFAULT_ZOOM: 0.75,
      PAUSE: 1,
      PLAY: 2,
      DRAGGING: 3,
      HOVER: 1,
      LOCK: 2,
      CLEAR: 0,
      GROUP: 1,
      GRAVITRON: 2,
      READY: 1,
      GL_UNSUPPORTED: 2,
      GL_WIMPY: 3,
      CENTERS_LOADED: 4,
      PARTICLES_LOADED: 5,
      MIN_ZOOM: 0.25,
      MAX_ZOOM: 4,
      HISTOGRAM_CHART_WIDTH: 216,
      HISTOGRAM_CHART_HEIGHT: 40,
      HISTOGRAM_TOP_MARGIN_HEIGHT: 20,
      FINISHED: 0,
      BEFORE: -1,
      AFTER: 86400,
      DRAG_THRESHHOLD_SQUARED: 20 * 20
    };
    constants.SECONDS_PER_HISTOGRAM_BUCKET = 60 * constants.HISTOGRAM_MINUTES_PER_BUCKET;
    constants.HISTOGRAM_INTERVAL_COUNT = constants.AFTER / constants.SECONDS_PER_HISTOGRAM_BUCKET;
    (function() {
      var TAU = Math.PI * 2, cos = Math.cos, sin = Math.sin, a;
      for(var i = 0; i < 7; i++) {
        a = TAU * i / 6;
        constants.HEX_ANGLES[i] = [cos(a), sin(a)]
      }
    }
    )();
    var requiredModules = ("dom,dataLoader,intro,particles,footer,histo,legend,particulate,zoomControls,particleGL,Lerper,Gravitron,ArcGroup,BezierPath,OuterPath,IntraRingPath").split(",")
    , firstRun = true;
    function init() {
      for(var i = requiredModules.length - 1; i >= 0; i--) {
        var moduleName = requiredModules[i];
        if(!app[moduleName]) {
          setTimeout(init, 1);
          if(firstRun) {
            firstRun = false
          }
          return
        }
      }
      app.listen(constants.APP_LAUNCH_EVENT, app.particulate.init);
      app.listen(constants.APP_LAUNCH_EVENT, app.dom.init);
      app.listen(constants.APP_LAUNCH_EVENT, app.dataLoader.load);
      app.dom.listen(constants.DOM_READY_EVENT, app.dataLoader.setLabelTemplate);
      app.dom.listen(constants.APP_LAUNCH_EVENT, app.intro.setDomReady);
      app.dom.listen(constants.SELECT_EVENT, app.particles.handleSelect);
      app.dom.listen(constants.RESIZE_EVENT, app.particulate.setSize);
      app.dom.listen(constants.RESIZE_EVENT, app.particleGL.setSize);
      app.dom.listen(constants.RESIZE_EVENT, app.footer.setSize);
      app.dom.listen(constants.RESIZE_EVENT, app.zoomControls.setSize);
      app.dataLoader.listen(constants.NODES_INITIALIZED_EVENT, app.particulate.setData);
      app.dataLoader.listen(constants.NODES_INITIALIZED_EVENT, app.particleGL.setData);
      app.dataLoader.listen(constants.NODES_INITIALIZED_EVENT, app.legend.setData);
      app.dataLoader.listen(constants.DATA_LOAD_EVENT, app.particulate.setData);
      app.dataLoader.listen(constants.DATA_LOAD_EVENT, app.histo.setData);
      app.dataLoader.listen(constants.DATA_LOAD_EVENT, app.particles.setData);
      app.dataLoader.listen(constants.NODES_INITIALIZED_EVENT, app.intro.setData);
      app.intro.listen(constants.SELECT_EVENT, app.legend.handleSelect);
      app.intro.listen(constants.ZOOM_PAN_EVENT, app.particulate.setZoomPan);
      app.intro.listen(constants.ZOOM_PAN_EVENT, app.zoomControls.setZoomPan);
      app.intro.listen(constants.LEGEND_SPEED_EVENT, app.legend.setSpeedParams);
      app.intro.listen(constants.LOOPER_CONTROL_EVENT, app.particulate.setUpdater);
      app.intro.listen(constants.INTRO_COMPLETE_EVENT, app.footer.bind);
      app.intro.listen(constants.INTRO_COMPLETE_EVENT, app.histo.bind);
      app.intro.listen(constants.INTRO_COMPLETE_EVENT, app.legend.bind);
      app.intro.listen(constants.INTRO_COMPLETE_EVENT, app.particulate.bind);
      app.intro.listen(constants.INTRO_COMPLETE_EVENT, app.zoomControls.bind);
      app.intro.listen(constants.INTRO_COMPLETE_EVENT, app.dom.endIntro);
      app.intro.listen(constants.INTRO_COMPLETE_EVENT, app.dom.activateControls);
      app.intro.listen(constants.INTRO_COMPLETE_EVENT, app.particles.handleIntroComplete);
      app.legend.listen(constants.SELECT_EVENT, app.particles.handleSelect);
      app.histo.listen(constants.TIME_UPDATE_EVENT, app.particles.setSecond);
      app.histo.listen(constants.PLAYBACK_EVENT, app.particles.setPlayback);
      app.histo.listen(constants.PLAYBACK_EVENT, app.particleGL.setPlayback);
      app.particles.listen(constants.DATA_LOAD_EVENT, app.particleGL.setParticleData);
      app.particles.listen(constants.TIME_UPDATE_EVENT, app.histo.setSecond);
      app.particles.listen(constants.SELECT_EVENT, app.legend.handleSelect);
      app.particles.listen(constants.SELECT_EVENT, app.footer.handleSelect);
      app.particles.listen(constants.SELECT_EVENT, app.histo.handleSelect);
      app.particles.listen(constants.SELECT_EVENT, app.particulate.handleSelect);
      app.particles.listen(constants.SELECT_EVENT, app.dom.handleSelect);
      app.particles.listen(constants.LOOPER_CONTROL_EVENT, app.particulate.setUpdater);
      app.particles.listen(constants.LOOPER_CONTROL_EVENT, app.particleGL.setUpdater);
      app.particles.listen(constants.PARTICLES_READY_EVENT, app.intro.showSkipOption);
      app.particles.listen(constants.BOX_FOCUS_EVENT, app.particulate.setFocus);
      app.particleGL.listen(constants.GL_STATUS_EVENT, app.dom.setWebGLNotOK);
      app.particleGL.listen(constants.GL_STATUS_EVENT, app.particulate.setParticleFunction);
      app.particleGL.listen(constants.GL_STATUS_EVENT, app.intro.setShaderReady);
      app.particleGL.listen(constants.GL_STATUS_EVENT, app.particles.setPathUpdateFunction);
      app.particulate.listen(constants.SELECT_EVENT, app.particles.handleSelect);
      app.particulate.listen(constants.ZOOM_PAN_EVENT, app.zoomControls.setZoomPan);
      app.particulate.listen(constants.SHARE_CONTROL_EVENT, app.particleGL.setZoomerPanner);
      app.zoomControls.listen(constants.ZOOM_PAN_EVENT, app.particulate.setZoomPan);
      app.zoomControls.listen(constants.ZOOM_RESET_EVENT, app.particles.handleZoomReset);
      app.announce(constants.APP_LAUNCH_EVENT)
    }
    var app = {
      constants: constants,
      loaded: false
    };
    F.eventify(app);
    window.app = app;
    init()
  }
  )(window.app);
  "use strict";
  (function(app) {
    var constants = app.constants, HEX_ANGLES = constants.HEX_ANGLES, GROUP_COLORS = constants.GROUP_COLORS, LERPING_GROUP_COUNT = GROUP_COLORS.length, LERP_RANGE = constants.LERP_RANGE, i, angleCount = constants.HEX_ANGLES.length - 1, round = Math.round, abs = Math.abs, PARTICLE_ALPHA = constants.PARTICLE_ALPHA, PARTICLE_HIGHLIGHT_ALPHA = constants.PARTICLE_HIGHLIGHT_ALPHA, PARTICLE_PUSHBACK_ALPHA = constants.PARTICLE_PUSHBACK_ALPHA, MAX_EVENT_COUNT = constants.MAX_EVENT_PARTICLE_COUNT;
    function Gravitron(id, name, subtype, group, colorGroupId, sizes, $label, description) {
      this.id = id;
      this.name = name;
      this.subtype = subtype;
      this.parent = group;
      this.colorGroupId = colorGroupId;
      this.MIN_SIZE = sizes.minSize;
      this.SIZE_RANGE = sizes.sizeRange;
      this.MIN_LAYOUT_SIZE = sizes.layoutMinSize;
      this.LAYOUT_SIZE_RANGE = sizes.layoutSizeRange;
      this.$label = $label;
      this.labelStyle = $label[0].style;
      this.labelWidth = false;
      this.description = description;
      this.groupId = group.groupId;
      this.labelWidth = $label.width();
      this.labelHeight = $label.height();
      var rgb = GROUP_COLORS[colorGroupId];
      this.rgbString = "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ",";
      this.binnedCounts = [];
      this.cumulativeCounts = [];
      for(var i = 0, L = constants.HISTOGRAM_INTERVAL_COUNT; i < L; i++) {
        this.binnedCounts[i] = 0
      }
      this.layoutSize = new F.SoftFloat(-1,0.2,0.5);
      this.size = new F.SoftFloat(0.001,0.2,0.5);
      this.alpha = new F.SoftFloat(0,0.2,0.5);
      this.paths = [];
      this.pathLookup = [];
      this.noiseMod = 0.01 + Math.random() * 0.03;
      this.noiseModAmt = this.noiseMod;
      this.movingCount = 0;
      this.fadingCount = 0
    }
    Gravitron.prototype.addPath = function(path) {
      this.paths.push(path);
      this.pathLookup[path.destination.id] = path
    }
    ;
    Gravitron.prototype.updateTargets = function() {
      var movingCount = this.movingCount
      , size = this.size
      , layoutSize = this.layoutSize;
      this.density = movingCount / MAX_EVENT_COUNT;
      if(movingCount > MAX_EVENT_COUNT) {
        size.setTarget(this.MIN_SIZE + this.SIZE_RANGE);
        layoutSize.setTarget(this.MIN_LAYOUT_SIZE + this.LAYOUT_SIZE_RANGE)
      } else {
        size.setTarget(this.MIN_SIZE + this.SIZE_RANGE * this.density);
        layoutSize.setTarget(this.MIN_LAYOUT_SIZE + this.LAYOUT_SIZE_RANGE * this.density)
      }
    }
    ;
    Gravitron.prototype.updateValues = function() {
      this.size.update();
      this.layoutSize.update();
      this.alpha.update();
      this.defaultAlpha = this.alpha.get();
      var perl = noise.perlin3(this.x / 100, this.y / 100, this.noiseMod);
      this.sparkleAlpha = this.defaultAlpha + abs(perl) * 0.35;
      this.noiseMod += this.noiseModAmt
    }
    ;
    Gravitron.prototype.updatePaths = function() {
      var paths = this.paths, maxPathCount = 0, path;
      for(var i = paths.length - 1; i >= 0; i--) {
        path = paths[i];
        path.setScatter(this.density);
        if(maxPathCount < path.currentCount) {
          maxPathCount = path.currentCount
        }
      }
      this.maxPathCount = maxPathCount
    }
    ;
    Gravitron.prototype.highlight = function() {
      this.highlightLabel();
      this.alpha.setTarget(PARTICLE_HIGHLIGHT_ALPHA)
    }
    ;
    Gravitron.prototype.unhighlight = function() {
      this.alpha.setTarget(PARTICLE_ALPHA);
      this.unhighlightLabel()
    }
    ;
    Gravitron.prototype.pushBack = function() {
      this.alpha.setTarget(PARTICLE_PUSHBACK_ALPHA);
      this.$label.removeClass("active");
      this.$label.css("opacity", 0)
    }
    ;
    Gravitron.prototype.highlightLabel = function() {
      this.$label.addClass("active");
      this.$label.css("opacity", 0.95);
      this.$label.addClass("hidden")
    }
    ;
    Gravitron.prototype.unhighlightLabel = function() {
      this.$label.css("opacity", 0);
      this.$label.removeClass("active")
    }
    ;
    Gravitron.prototype.highlightLabelByVolume = function(pathCount, maxPathCount) {
      var opa = pathCount / maxPathCount * 0.8;
      this.$label.css("opacity", opa);
      this.$label.removeClass("active")
    }
    ;
    Gravitron.prototype.positionLabel = function(x, y) {
      this.labelX = x;
      this.labelY = y;
      this.labelStyle.left = round(x) + "px";
      this.labelStyle.top = round(y) + "px"
    }
    ;
    Gravitron.prototype.getLabelWidth = function() {
      if(!this.labelWidth) {
        this.labelWidth = this.$label.width()
      }
      return this.labelWidth
    }
    ;
    Gravitron.prototype.getLabelHeight = function() {
      if(!this.labelHeight) {
        this.labelHeight = this.$label.height()
      }
      return this.labelHeight
    }
    ;
    Gravitron.prototype.draw = function(ctx, t) {
      var x = this.x, y = this.y, r = this.size.get() * 0.2, a, alf = this.sparkleAlpha;
      ctx.fillStyle = this.rgbString + (round(alf * 100) / 100) + ")";
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      for(i = 1; i < angleCount; i++) {
        a = HEX_ANGLES[i];
        ctx.lineTo(x + a[0] * r, y + a[1] * r)
      }
      ctx.lineTo(x + r, y);
      ctx.fill()
    }
    ;
    noise.seed(Math.random());
    app.Gravitron = Gravitron
  }
  )(app);
  "use strict";
  (function(app) {
    var constants = app.constants
    , PI = Math.PI
    , TAU = PI * 2
    , HALF_PI = PI * 0.5
    , cos = Math.cos
    , sin = Math.sin
    , round = Math.sin
    , INNER_RING_MARGIN_MIN = constants.INNER_RING_MARGIN_MIN
    , INNER_RING_MARGIN_RANGE = constants.INNER_RING_MARGIN_RANGE
    , SPACE_BETWEEN_ARCS = constants.ARC_EVENT_MARGIN
    , PRACTICE_EVENT_MARGIN = constants.PRACTICE_EVENT_MARGIN
    , PRACTICE_EVENT_MIN_SIZE = constants.PRACTICE_EVENT_MIN_SIZE
    , SUBGROUP_LABELS = constants.SUBGROUP_LABELS
    , SUBGROUP_INDICES = {};
    (function() {
      for(var i = 0, L = SUBGROUP_LABELS.length; i < L; i++) {
        SUBGROUP_INDICES[SUBGROUP_LABELS[i]] = i
      }
    }
    )();
    function Group(id, name, color, lerpColors, descriptionDict) {
      if(id == null) {
        return
      }
      this.groupId = id;
      this.name = name;
      this.description = descriptionDict[name];
      this.centers = [];
      this.centerLookup = [];
      this.rgb = color;
      this.lerpColors = lerpColors;
      this.binnedCounts = [];
      this.cumulativeCounts = [];
      for(var i = 0, L = constants.HISTOGRAM_INTERVAL_COUNT; i < L; i++) {
        this.binnedCounts[i] = 0
      }
    }
    Group.prototype.position = function(x, y) {
      this.x = x;
      this.y = y
    }
    ;
    Group.prototype.highlight = function() {
      this.centers.forEach(highlightGravitron)
    }
    ;
    Group.prototype.unhighlight = function() {
      this.centers.forEach(unhighlightGravitron)
    }
    ;
    Group.prototype.pushBack = function() {
      this.centers.forEach(pushBackGravitron)
    }
    ;
    Group.prototype.getBounds = function() {
      var top = 10000, bottom = -10000, right = -10000, left = 10000, grav, s, x, y, centers = this.centers;
      for(var i = centers.length - 1; i >= 0; i--) {
        grav = centers[i];
        s = grav.layoutSize.getTarget();
        x = grav.x;
        y = grav.y;
        if(left > x - s) {
          left = x - s
        }
        if(right < x + s) {
          right = x + s
        }
        if(top > y - s) {
          top = y - s
        }
        if(bottom < y + s) {
          bottom = y + s
        }
      }
      return {
        left: left,
        top: top,
        right: right,
        bottom: bottom
      }
    }
    ;
    function highlightGravitron(g) {
      g.highlight()
    }
    function unhighlightGravitron(g) {
      g.unhighlight()
    }
    function pushBackGravitron(g) {
      g.pushBack()
    }
    function SuperGroup(id, name, color, lerpColors, descriptionDict) {
      Group.call(this, id, name, color, lerpColors, descriptionDict);
      var GROUP_COLORS = constants.GROUP_COLORS;
      this.arcs = [];
      this.encounter = new ArcGroup(4,SUBGROUP_LABELS[0],color,lerpColors,descriptionDict);
      this.encounter.margin = 0;
      this.encounter.startAngle = -HALF_PI;
      this.encounter.centerAngle = -HALF_PI;
      this.arcs[0] = this.encounter;
      for(var i = 1; i < 4; i++) {
        this.arcs[i] = new ArcGroup(i + 4,SUBGROUP_LABELS[i],GROUP_COLORS[4],lerpColors,descriptionDict)
      }
      this.ring = new RingGroup(this.arcs.slice(1));
      this.encounterMinSize = 0;
      this.RING_MIN = INNER_RING_MARGIN_MIN;
      this.RING_RANGE = INNER_RING_MARGIN_RANGE
    }
    SuperGroup.prototype.position = function(x, y) {
      this.x = x;
      this.y = y;
      var arcs = this.arcs;
      for(var i = 0, L = arcs.length; i < L; i++) {
        arcs[i].position(x, y)
      }
    }
    ;
    SuperGroup.prototype.addNode = function(node) {
      this.centerLookup[node.id] = node;
      this.centers.push(node);
      var subGroupIndex = SUBGROUP_INDICES[node.subtype];
      this.arcs[subGroupIndex].addNode(node);
      node.parent = this.arcs[subGroupIndex];
      node.subGroupId = subGroupIndex;
      if(0 === subGroupIndex) {
        this.encounterMinSize = this.encounter.centers.length * 2 * (PRACTICE_EVENT_MIN_SIZE + PRACTICE_EVENT_MARGIN)
      }
    }
    ;
    SuperGroup.prototype.update = function() {
      var l = this.encounter.getLength();
      this.radius = l / TAU;
      this.encounter.resize(this.radius);
      this.encounter.startAngle = -HALF_PI;
      this.encounter.update();
      this.ring.update(this.radius + this.RING_MIN + l / this.encounterMinSize * this.RING_RANGE);
      this.radius = this.ring.radius
    }
    ;
    SuperGroup.prototype.updatePaths = function() {
      var arcs = this.arcs;
      for(var i = 0, L = arcs.length; i < L; i++) {
        arcs[i].updatePaths()
      }
    }
    ;
    SuperGroup.prototype.getPathRadius = function() {
      return this.radius
    }
    ;
    function ArcGroup(id, name, color, lerpColors, descriptionDict) {
      Group.call(this, id, name, color, lerpColors, descriptionDict);
      this.margin = 0;
      this.startAngle = 0;
      this.endAngle = 0
    }
    ArcGroup.prototype.getLength = function() {
      var l = 0, space, g, centers = this.centers, m = this.margin, L = centers.length;
      for(var i = 0; i < L; i++) {
        g = centers[i];
        space = g.layoutSize.get() * 2;
        if(space < 0.001) {
          space = 0.001
        }
        space += m;
        l += space;
        l += space
      }
      return l
    }
    ;
    ArcGroup.prototype.resize = function(radius) {
      var l = this.getLength();
      this.radius = radius;
      this.circumference = TAU * radius;
      this.startAngle = this.centerAngle - l / (this.circumference || 1)
    }
    ;
    ArcGroup.prototype.update = function(extraMargin, startAngle) {
      var angle = startAngle || this.startAngle, m = this.margin || 0, angleIncr = 0, space, g, centers = this.centers, wedgeCoefficient = TAU / this.circumference;
      while (angle > PI) {
        angle -= TAU
      }
      while (angle < -PI) {
        angle += TAU
      }
      m += extraMargin || 0;
      this.startAngle = angle;
      for(var i = 0, L = centers.length; i < L; i++) {
        g = centers[i];
        space = g.layoutSize.get() * 2;
        if(space < 0) {
          space = 0
        }
        space += m;
        angleIncr = space * wedgeCoefficient;
        angle += angleIncr;
        if(angle > PI) {
          angle -= TAU
        }
        g.x = this.x + cos(angle) * this.radius;
        g.y = this.y + sin(angle) * this.radius;
        g.distance = this.radius;
        g.groupAngle = angle;
        angle += angleIncr
      }
      this.endAngle = angle
    }
    ;
    ArcGroup.prototype.updatePaths = function() {
      var centers = this.centers;
      for(var i = 0, L = centers.length; i < L; i++) {
        centers[i].updatePaths()
      }
    }
    ;
    ArcGroup.prototype.addNode = function(node) {
      this.centerLookup[node.id] = node;
      this.centers.push(node)
    }
    ;
    function RingGroup(arcs) {
      this.arcs = arcs;
      this.x = 0;
      this.y = 0;
      this.radius = 0;
      this.circumference = 0;
      arcs[0].centerAngle = -HALF_PI;
      arcs[1].centerAngle = HALF_PI / 6;
      arcs[2].centerAngle = HALF_PI / 6 * 5
    }
    RingGroup.prototype.position = function(x, y) {
      this.x = x;
      this.y = y
    }
    ;
    RingGroup.prototype.update = function(minRadius) {
      var arcs = this.arcs, circumference = 0, arcCircumference, gravCount = 0, gravitronMargin = 0;
      for(var a = 0, aL = arcs.length; a < aL; a++) {
        arcCircumference = arcs[a].getLength();
        circumference += arcCircumference + SPACE_BETWEEN_ARCS;
        gravCount += arcs[a].centers.length
      }
      this.circumference = circumference;
      this.radius = circumference / TAU;
      if(this.radius < minRadius) {
        this.radius = minRadius;
        circumference = TAU * minRadius;
        gravitronMargin = (circumference - this.circumference) / gravCount / 2;
        this.circumference = circumference
      } else {
        gravitronMargin = false
      }
      var marginAngle = SPACE_BETWEEN_ARCS / circumference * TAU
      , a = HALF_PI + marginAngle / 2;
      var index, ea;
      for(var i = 0, L = arcs.length; i < L; i++) {
        index = (i + L - 1) % L;
        arcs[index].resize(this.radius);
        arcs[index].update(gravitronMargin, a);
        ea = arcs[index].endAngle;
        a = ea;
        a += marginAngle
      }
    }
    ;
    F.inheritFrom(Group, SuperGroup);
    F.inheritFrom(Group, ArcGroup);
    app.SuperGroup = SuperGroup;
    app.ArcGroup = ArcGroup;
    app.RingGroup = RingGroup
  }
  )(app);
  "use strict";
  (function(app) {
    var X = 0;
    var Y = 1;
    var DISTANCE = 2;
    var PROGRESS = 3;
    var DX = 4;
    var DY = 5;
    var DPROGRESS = 6;
    var constants = app.constants
    , sin = Math.sin
    , cos = Math.cos
    , pow = Math.pow
    , HALF_PI = Math.PI / 2
    , PI = Math.PI
    , TAU = Math.PI * 2
    , atan2 = Math.atan2
    , sqrt = Math.sqrt
    , abs = Math.abs
    , PATH_TYPES = constants.PATH_TYPES
    , PARTICLE_SCATTER_BASE = constants.PARTICLE_SCATTER_BASE
    , PARTICLE_SCATTER_RANGE = constants.PARTICLE_SCATTER_RANGE
    , PARTICLE_SCATTER_LIMIT = constants.PARTICLE_SCATTER_LIMIT
    , PARTICLE_WEIGHT_BASE = constants.PARTICLE_WEIGHT_BASE
    , PARTICLE_WEIGHT_DENOMINATOR_BASE = constants.PARTICLE_WEIGHT_DENOMINATOR_BASE
    , PARTICLE_WEIGHT_SCALE = constants.PARTICLE_WEIGHT_SCALE
    , PARTICLE_WEIGHT_POWER = constants.PARTICLE_WEIGHT_POWER
    , MIN_PARTICLE_WEIGHT = constants.MIN_PARTICLE_WEIGHT
    , MAX_PARTICLE_WEIGHT = constants.MAX_PARTICLE_WEIGHT
    , TRAVEL_PIXELS = constants.TRAVEL_PIXELS;
    function BezierPath(origin, destination) {
      this.origin = origin;
      this.destination = destination;
      this.scatter = 1;
      this.particleWeight = 1;
      this.densityMeasure = 1;
      this.currentCount = 0;
      this.pathType = PATH_TYPES.BEZIER;
      this.progressIncrement = 0.001
    }
    BezierPath.prototype.setLength = function(length) {
      this.length = length;
      this.densityMeasure = length > 300 ? 1 : 0.25 + (0.75 * length / 300);
      this.progressIncrement = TRAVEL_PIXELS / (length || 1)
    }
    ;
    BezierPath.prototype.updateParticle = function(mp) {
      mp.progress += this.progressIncrement * mp.velocityMod;
      mp.weight = this.particleWeight
    }
    ;
    BezierPath.prototype.setScatter = function(gravitronTraffic) {
      this.scatter = PARTICLE_SCATTER_BASE + PARTICLE_SCATTER_RANGE * gravitronTraffic;
      if(this.scatter > PARTICLE_SCATTER_LIMIT) {
        this.scatter = PARTICLE_SCATTER_LIMIT
      }
      if(gravitronTraffic > 1) {
        if(gravitronTraffic > 3) {
          this.particleWeight = this.densityMeasure * PARTICLE_WEIGHT_BASE / (4 + pow(gravitronTraffic - 3, 0.3))
        } else {
          this.particleWeight = this.densityMeasure * PARTICLE_WEIGHT_BASE / (1 + gravitronTraffic)
        }
      } else {
        this.particleWeight = this.densityMeasure * PARTICLE_WEIGHT_BASE / 2
      }
      if(this.particleWeight < MIN_PARTICLE_WEIGHT) {
        this.particleWeight = MIN_PARTICLE_WEIGHT
      } else {
        if(this.particleWeight > MAX_PARTICLE_WEIGHT) {
          this.particleWeight = MAX_PARTICLE_WEIGHT
        }
      }
    }
    ;
    BezierPath.prototype.incrementCurrentCount = function() {
      this.currentCount++
    }
    ;
    BezierPath.prototype.decrementCurrentCount = function() {
      if(this.currentCount > 0) {
        this.currentCount--
      }
    }
    ;
    app.BezierPath = BezierPath
  }
  )(window.app);
  "use strict";
  (function(app) {
    var X = 0;
    var Y = 1;
    var DISTANCE = 2;
    var PROGRESS = 3;
    var DX = 4;
    var DY = 5;
    var DPROGRESS = 6;
    var constants = app.constants
    , PATH_TYPES = constants.PATH_TYPES
    , OUTSIDE_PATH_MIN_HEIGHT = 18
    , OUTSIDE_PATH_HEIGHT_RANGE = 180
    , OUTSIDE_PATH_MAX_HEIGHT = OUTSIDE_PATH_MIN_HEIGHT + OUTSIDE_PATH_HEIGHT_RANGE
    , SUPERGROUP_OUTSIDE_PATH_MIN_HEIGHT = 5
    , SUPERGROUP_OUTSIDE_PATH_HEIGHT_RANGE = 65
    , SUPERGROUP_OUTSIDE_PATH_MAX_HEIGHT = SUPERGROUP_OUTSIDE_PATH_MIN_HEIGHT + SUPERGROUP_OUTSIDE_PATH_HEIGHT_RANGE
    , TRAVEL_PIXELS = constants.TRAVEL_PIXELS
    , MAX_EVENT_COUNT = 40
    , PI = Math.PI
    , TAU = PI * 2
    , HALF_PI = PI * 0.5
    , sin = Math.sin
    , cos = Math.cos
    , pow = Math.pow
    , abs = Math.abs
    , sqrt = Math.sqrt;
    function OuterPath(origin, destination) {
      if(!origin) {
        return
      }
      app.BezierPath.call(this, origin, destination);
      this.pathType = PATH_TYPES.OUTER;
      this.initialized = true
    }
    OuterPath.prototype.setHeight = function(aDiff) {
      this.height = map(pow(abs(aDiff) / PI * this.scatter, 0.5), 0, 1, OUTSIDE_PATH_MIN_HEIGHT, OUTSIDE_PATH_MAX_HEIGHT)
    }
    ;
    OuterPath.prototype.setLength = function(length) {
      if(this.currentCount < MAX_EVENT_COUNT) {
        this.densityMeasure = 1 + (1 - this.currentCount / MAX_EVENT_COUNT)
      } else {
        this.densityMeasure = 1
      }
      this.length = length;
      this.progressIncrement = TRAVEL_PIXELS / length
    }
    ;
    function SuperGroupOuterPath(origin, destination) {
      OuterPath.call(this, origin, destination);
      this.pathType = PATH_TYPES.SUPER_OUTER
    }
    SuperGroupOuterPath.prototype.setHeight = function(aDiff) {
      this.height = map(pow(abs(aDiff) / PI * this.scatter, 0.5), 0, 1, SUPERGROUP_OUTSIDE_PATH_MIN_HEIGHT, SUPERGROUP_OUTSIDE_PATH_MAX_HEIGHT)
    }
    ;
    function map(v, i1, i2, o1, o2) {
      return o1 + (v - i1) / (i2 - i1) * (o2 - o1)
    }
    F.inheritFrom(app.BezierPath, OuterPath);
    F.inheritFrom(OuterPath, SuperGroupOuterPath);
    app.OuterPath = OuterPath;
    app.SuperGroupOuterPath = SuperGroupOuterPath
  }
  )(window.app);
  "use strict";
  (function(app) {
    var X = 0;
    var Y = 1;
    var DISTANCE = 2;
    var PROGRESS = 3;
    var DX = 4;
    var DY = 5;
    var DPROGRESS = 6;
    var constants = app.constants
    , sin = Math.sin
    , cos = Math.cos
    , pow = Math.pow
    , HALF_PI = Math.PI / 2
    , PI = Math.PI
    , TAU = Math.PI * 2
    , atan2 = Math.atan2
    , sqrt = Math.sqrt
    , abs = Math.abs
    , PATH_TYPES = constants.PATH_TYPES
    , TRAVEL_PIXELS = constants.TRAVEL_PIXELS;
    function IntraRingPath(origin, destination) {
      if(!origin) {
        return
      }
      app.BezierPath.call(this, origin, destination);
      this.pathType = PATH_TYPES.INTRA
    }
    IntraRingPath.prototype.getMidRadiusBase = function() {
      return this.origin.parent.radius
    }
    ;
    IntraRingPath.prototype.getRadDiffModifier = function(aDiff) {
      var aPct = abs(aDiff / PI);
      return 0.15 + aPct * 0.62
    }
    ;
    IntraRingPath.prototype.setLength = function(length) {
      this.densityMeasure = 1;
      this.length = length;
      this.progressIncrement = TRAVEL_PIXELS / length
    }
    ;
    function SuperGroupIntraRingPath(origin, destination) {
      IntraRingPath.call(this, origin, destination);
      this.pathType = PATH_TYPES.SUPER_INTRA
    }
    SuperGroupIntraRingPath.prototype.getMidRadiusBase = function() {
      return this.origin.distance
    }
    ;
    SuperGroupIntraRingPath.prototype.getRadDiffModifier = function(aDiff) {
      return 0.15 + abs(aDiff / PI) * 0.27
    }
    ;
    function map(v, i1, i2, o1, o2) {
      return o1 + (v - i1) / (i2 - i1) * (o2 - o1)
    }
    F.inheritFrom(app.BezierPath, IntraRingPath);
    F.inheritFrom(IntraRingPath, SuperGroupIntraRingPath);
    app.IntraRingPath = IntraRingPath;
    app.SuperGroupIntraRingPath = SuperGroupIntraRingPath
  }
  )(window.app);
  "use strict";
  (function(app) {
    var constants = app.constants
    , HEX_ANGLES = constants.HEX_ANGLES
    , angleCount = HEX_ANGLES.length - 1
    , floor = Math.floor
    , PARTICLE_VELOCITY_MOD = constants.PARTICLE_VELOCITY_MOD;
    function Lerper(offset, offset2) {
      this.position = [];
      this.offset = offset;
      this.velocityMod = PARTICLE_VELOCITY_MOD * offset2;
      this.complete = true
    }
    Lerper.prototype.set = function(origin, destination) {
      this.origin = origin;
      this.destination = destination;
      this.position[0] = origin.x + this.offset[0];
      this.position[1] = origin.y + this.offset[1];
      this.complete = false;
      this.progress = 0;
      this.pathIndex = 0;
      this.path = origin.pathLookup[destination.id];
      this.pathType = this.path.pathType;
      this.path.incrementCurrentCount();
      this.originId = origin.id;
      this.destinationId = destination.id;
      origin.movingCount++
    }
    ;
    Lerper.prototype.update = function() {
      this.path.updateParticle(this);
      if(this.progress >= 0.9999) {
        this.complete = true;
        this.path.decrementCurrentCount();
        this.origin.movingCount--
      }
    }
    ;
    Lerper.prototype.isComplete = function() {
      return this.complete
    }
    ;
    app.Lerper = Lerper
  }
  )(window.app);
  "use strict";
  (function(app) {
    var constants = app.constants, $footer = $("#footer"), $captionPositioner = $footer.find("#caption-positioner"), $caption = $footer.find("#caption-wrapper"), $title = $caption.find("#caption-title"), $text = $caption.find("#caption-text"), $infoButton = $footer.find("#info-button"), $infoButtonIcon = $infoButton.find(".icon"), defaultTitle = $("#caption-title").html(), defaultText = $("#caption-text").html(), defaultItem = {
      name: defaultTitle,
      description: defaultText
    }, fadeTimer = false, pulseTimer, pulsing = true, firstExpansion = true, GRAVITRON = constants.GRAVITRON, CLEAR = constants.CLEAR;
    function bind() {
      $infoButton.bind("click", expandAbout);
      $footer.find("#explain").bind("click", expandAbout);
      $footer.on("mousedown", function(evt) {
        evt.stopPropagation()
      });
      var infoButtonLabel = $infoButton.find(".label")[0];
      $footer.on("mousemove", function(evt) {
        evt.stopPropagation();
        if($(evt.target).text() == "Read more" || evt.target == $infoButtonIcon[0] || evt.target == infoButtonLabel) {
          $footer.find("#explain").addClass("hover");
          $infoButton.addClass("hover");
          if(pulsing) {
            $infoButtonIcon.removeClass("pulsar");
            $infoButtonIcon.removeClass("pulse");
            pulsing = false;
            clearTimeout(pulseTimer);
            pulseTimer = false
          }
        } else {
          $footer.find("#explain").removeClass("hover");
          $infoButton.removeClass("hover")
        }
      });
      $footer.find(".inactive").removeClass("inactive");
      pulseOut()
    }
    function pulseIn() {
      if(pulsing) {
        $infoButtonIcon.addClass("pulse");
        pulseTimer = setTimeout(pulseOut, 1250)
      }
    }
    function pulseOut() {
      $infoButtonIcon.removeClass("pulse");
      if(pulsing) {
        pulseTimer = setTimeout(pulseIn, 1250)
      }
    }
    function setSize(sizes) {
      var captionWidth = $caption.width();
      $caption.css("position", "absolute");
      var margin = ~~((sizes.width - captionWidth) / 2);
      $caption.css("right", margin + "px")
    }
    function expandAbout() {
      $footer.find("#explain").removeClass("hover");
      $infoButton.removeClass("hover");
      $infoButton.unbind();
      $footer.find("#explain").unbind();
      $footer.addClass("expanded");
      $infoButtonIcon.text("x");
      $infoButton.bind("click", function() {
        $footer.find("#explain").removeClass("hover");
        $infoButton.removeClass("hover");
        $infoButton.unbind();
        $footer.removeClass("expanded");
        $infoButtonIcon.text("i");
        $infoButton.bind("click", expandAbout);
        $footer.find("#explain").bind("click", expandAbout)
      });
      if(firstExpansion) {
        firstExpansion = false;
        $infoButtonIcon.addClass("pulsar");
        pulsing = true;
        pulseIn()
      }
    }
    var currentTitle = false
    , currentDescription = false
    , nextTitle = false
    , nextDescription = false;
    function setSelection(title, description) {
      title = title || "&nbsp;";
      description = description || "&nbsp;";
      if(title !== currentTitle || description !== currentDescription) {
        if(title === nextTitle && description === nextDescription && fadeTimer) {
          return
        }
        nextTitle = title;
        nextDescription = description;
        $caption.addClass("faded");
        if(fadeTimer) {
          clearTimeout(fadeTimer);
          fadeTimer = false
        }
        fadeTimer = setTimeout(setTexts, 250)
      } else {
        if(title !== nextTitle || description !== nextDescription) {
          nextTitle = title;
          nextDescription = description
        }
      }
    }
    function setTexts() {
      fadeTimer = false;
      currentTitle = nextTitle;
      currentDescription = nextDescription;
      $title.html(currentTitle);
      $text.html(currentDescription);
      if(currentDescription == defaultText) {
        $captionPositioner.removeClass("double");
        $footer.find("#explain").bind("click", expandAbout)
      } else {
        if($text.height() > 20) {
          $captionPositioner.addClass("double")
        } else {
          $captionPositioner.removeClass("double")
        }
      }
      $caption.removeClass("faded")
    }
    function handleSelect(params) {
      var item = params.item;
      if(item) {
        if(params.type == constants.GRAVITRON) {
          $caption.addClass("streamlined");
          setSelection(false, item.description)
        } else {
          $caption.removeClass("streamlined");
          setSelection((params.label || item.name), item.description)
        }
      } else {
        setSelection(defaultItem.name, defaultItem.description);
        $caption.removeClass("streamlined");
        $footer.find("#explain").bind("click", expandAbout)
      }
    }
    var footer = {
      bind: bind,
      handleSelect: handleSelect,
      setSelection: setSelection,
      setSize: setSize
    };
    F.eventify(footer);
    app.footer = footer
  }
  )(window.app);
  "use strict";
  (function(app) {
    var constants = app.constants, canvas, ctx, W, H, floor = Math.floor, round = Math.round, TAU = Math.PI * 2, CHART_WIDTH = constants.HISTOGRAM_CHART_WIDTH, CHART_HEIGHT = constants.HISTOGRAM_CHART_HEIGHT, TOP_MARGIN = constants.HISTOGRAM_TOP_MARGIN_HEIGHT, CHART_BOTTOM = TOP_MARGIN + CHART_HEIGHT, GROUP_COUNT = constants.GROUP_COUNT, GROUP_COLORS = constants.GROUP_COLORS, PLAY_CHAR = "p", PAUSE_CHAR = "u", $clockDiv, $hourSpan, $minuteSpan, $secondSpan, $ampmSpan, $seriesName, $seriesCount, SAMPLE_SCALEUP = 4, commify = F.NumberLabeler.commify, SECONDS_PER_BUCKET_INTERVAL = constants.HISTOGRAM_MINUTES_PER_BUCKET * 60, AFTER = constants.AFTER, BAR_COUNT = floor(AFTER / SECONDS_PER_BUCKET_INTERVAL);
    var t, looping = false, interval, second, BAR_SPACING = CHART_WIDTH / BAR_COUNT, BAR_WIDTH = BAR_SPACING - 1, xpositions, displaySeries, displayMax, bars, SoftFloat = F.SoftFloat, groups, total, TIME_UPDATE_EVENT = constants.TIME_UPDATE_EVENT, PLAYBACK_EVENT = constants.PLAYBACK_EVENT, PAUSE = constants.PAUSE, PLAY = constants.PLAY, DRAGGING = constants.DRAGGING, GROUP_COLOR_STRINGS = [], ACTIVE_GROUP_COLOR_STRINGS = [], TIMELINE_TOP = CHART_BOTTOM + 10, TIMELINE_HT = 4, TIMELINE_LEFT = 15, TIMELINE_BOTTOM = TIMELINE_TOP + TIMELINE_HT + 6, SUBTITLE_DOT_YPOS = TIMELINE_TOP + 20, markerXpos, paused = false, thumbColor, priorMousedIndex = -1;
    var dragged = false, DRAG_THRESHHOLD_SQUARED = constants.DRAG_THRESHHOLD_SQUARED, mouseIsDown = false, mouseMoveWhilePaused = false, downTime, startX, startY, mousedItem, THUMB = 10;
    function init() {
      canvas = $("#histo")[0];
      ctx = canvas.getContext("2d");
      W = $(canvas).width();
      H = $(canvas).height();
      if(window.devicePixelRatio > 1) {
        canvas.width = W * window.devicePixelRatio;
        canvas.height = H * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio)
      } else {
        canvas.width = W;
        canvas.height = H
      }
      $clockDiv = $("#series-time");
      $hourSpan = $clockDiv.find("#hh");
      $minuteSpan = $clockDiv.find("#mm");
      $secondSpan = $clockDiv.find("#ss");
      $ampmSpan = $clockDiv.find("#ampm");
      $seriesName = $("#series-name");
      $seriesCount = $("#series-count");
      GROUP_COLOR_STRINGS = [];
      var c;
      for(var i = 0, L = GROUP_COLORS.length; i < L; i++) {
        c = GROUP_COLORS[i];
        GROUP_COLOR_STRINGS[i] = "rgba(" + c[0] + "," + c[1] + "," + c[2] + ","
      }
      for(var i = 0; i < L - 1; i++) {
        ACTIVE_GROUP_COLOR_STRINGS[i] = GROUP_COLOR_STRINGS[i]
      }
      xpositions = [];
      bars = [];
      for(var i = 0; i < BAR_COUNT; i++) {
        bars[i] = [];
        for(var g = 0; g < GROUP_COUNT; g++) {
          bars[i].push(new SoftFloat(0))
        }
        xpositions[i] = TIMELINE_LEFT + i * BAR_SPACING
      }
      thumbColor = new SoftFloat(150);
      ctx.font = "12px icons";
      ctx.textBaseline = "middle"
    }
    function setData(data) {
      groups = data.groups;
      total = data.total;
      setSeries(total)
    }
    function setSecond(s) {
      second = s;
      interval = floor(second / SECONDS_PER_BUCKET_INTERVAL);
      var m = floor(second / 60) % 60
      , h = floor(second / 3600)
      , am = h < 12 ? "am" : "pm";
      if(h == 0) {
        h = 12
      } else {
        if(h > 12) {
          h %= 12
        }
      }
      $hourSpan.text(h);
      $minuteSpan.text((m < 10 ? "0" : "") + m);
      $ampmSpan.text(am);
      if(displaySeries) {
        $seriesCount.text(commify(displaySeries.cumulativeCounts[second] * SAMPLE_SCALEUP))
      }
      markerXpos = TIMELINE_LEFT + CHART_WIDTH * second / AFTER;
      launchLoop()
    }
    function setSeries(item, label) {
      if(item == displaySeries || !item || item.binMax === undefined) {
        return
      }
      displaySeries = item;
      displayMax = item.binMax;
      $seriesName.text(label || item.name);
      $seriesCount.text(commify(item.cumulativeCounts[second] * SAMPLE_SCALEUP));
      var barScale = CHART_HEIGHT / displayMax;
      if(displaySeries == total) {
        ACTIVE_GROUP_COLOR_STRINGS[0] = GROUP_COLOR_STRINGS[0];
        for(var i = 0; i < BAR_COUNT; i++) {
          for(var g = 0; g < GROUP_COUNT; g++) {
            bars[i][g].setTarget(groups[g].binnedCounts[i] * barScale)
          }
        }
      } else {
        var groupId = item.groupId, counts = item.binnedCounts, c, h;
        if(groupId == 0 && undefined != item.subGroupId) {
          groupId = 4 + item.subGroupId
        }
        if(groupId > 4) {
          ACTIVE_GROUP_COLOR_STRINGS[0] = GROUP_COLOR_STRINGS[4]
        } else {
          ACTIVE_GROUP_COLOR_STRINGS[0] = GROUP_COLOR_STRINGS[0]
        }
        if(groupId >= 4) {
          groupId = 0
        }
        for(var i = 0; i < BAR_COUNT; i++) {
          for(var g = 0; g < GROUP_COUNT; g++) {
            if(g == groupId) {
              c = counts[i];
              h = c * barScale;
              bars[i][g].setTarget(h)
            } else {
              bars[i][g].setTarget(0)
            }
          }
        }
      }
    }
    function draw() {
      var n = Date.now() + 10;
      var bh, th, bar, xpos, fs;
      ctx.clearRect(0, 0, W, H);
      for(var i = 0; i < BAR_COUNT; i++) {
        th = CHART_BOTTOM;
        xpos = xpositions[i];
        for(var g = GROUP_COUNT - 1; g >= 0; g--) {
          bar = bars[i][g];
          bar.update();
          bh = bar.get();
          fs = ACTIVE_GROUP_COLOR_STRINGS[g];
          fs += (i <= interval ? ".95" : ".5") + ")";
          ctx.fillStyle = ACTIVE_GROUP_COLOR_STRINGS[g] + (i <= interval ? ".95" : ".5") + ")";
          ctx.fillRect(xpos, th, BAR_WIDTH, -bh);
          th -= bh
        }
      }
      drawTimeline();
      n -= Date.now();
      if(n <= 0) {
        n = 1
      }
      setTimeout(requestFrame, n)
    }
    function drawTimeline() {
      ctx.fillStyle = "rgb(240,240,240)";
      ctx.fillRect(TIMELINE_LEFT, TIMELINE_TOP, CHART_WIDTH, TIMELINE_HT);
      var priorgrey = -1, grey;
      thumbColor.update();
      grey = round(thumbColor.get());
      ctx.fillStyle = "rgb(" + grey + "," + grey + "," + grey + ")";
      ctx.font = "16px icons";
      ctx.fillText(paused ? PLAY_CHAR : PAUSE_CHAR, markerXpos - 15.5, TIMELINE_TOP + 1)
    }
    function launchLoop() {
      if(!looping) {
        looping = true;
        requestFrame()
      }
    }
    function requestFrame() {
      requestAnimationFrame(draw)
    }
    init();
    function bind() {
      $(canvas).unbind();
      $(canvas).bind("mousemove", handleMouseMove);
      $(canvas).bind("mousedown", handleMouseDown);
      $(canvas).bind("mouseup", handleMouseUp)
    }
    function getInterval(x) {
      var erval = (x - TIMELINE_LEFT) / BAR_SPACING;
      if(erval < 0) {
        erval = 0
      }
      if(erval >= xpositions.length) {
        erval = xpositions.length - 1
      }
      return floor(erval)
    }
    function getTimelineItemCode(x, y) {
      var code = false;
      if(y > TIMELINE_TOP - 4) {
        if(y < TIMELINE_BOTTOM) {
          if(x <= markerXpos + 5 && x >= markerXpos - 20) {
            code = THUMB
          }
        }
      }
      return code
    }
    function handleMouseMove(eventData) {
      eventData.stopPropagation();
      var x = eventData.offsetX
      , y = eventData.offsetY
      , code = false;
      if(mouseIsDown) {
        var indx = getInterval(x)
        , dx = x - startX
        , dy = y - startY
        , d2 = dx * dx + dy * dy;
        if(indx != priorMousedIndex) {
          if(paused) {
            histo.announce(PLAYBACK_EVENT, PLAY);
            setTimeout(function() {
              histo.announce(PLAYBACK_EVENT, PAUSE)
            }, 300)
          }
          histo.announce(TIME_UPDATE_EVENT, indx * SECONDS_PER_BUCKET_INTERVAL);
          priorMousedIndex = indx
        } else {}
        if(d2 >= DRAG_THRESHHOLD_SQUARED) {
          dragged = true
        }
      } else {
        code = getTimelineItemCode(x, y)
      }
      if(code == THUMB) {
        thumbColor.setTarget(100);
        $(canvas).addClass("thumbing")
      } else {
        thumbColor.setTarget(180);
        $(canvas).removeClass("thumbing")
      }
    }
    function handleMouseDown(eventData) {
      eventData.stopPropagation();
      startX = eventData.offsetX,
      startY = eventData.offsetY;
      mousedItem = getTimelineItemCode(startX, startY);
      histo.announce(PLAYBACK_EVENT, DRAGGING);
      if(!mousedItem && startY < TIMELINE_BOTTOM) {
        var indx = getInterval(startX);
        priorMousedIndex = indx;
        histo.announce(TIME_UPDATE_EVENT, indx * SECONDS_PER_BUCKET_INTERVAL)
      }
      mouseIsDown = true;
      downTime = Date.now()
    }
    function handleMouseUp(eventData) {
      eventData.stopPropagation();
      if(!dragged) {
        if(mousedItem !== false) {
          if(mousedItem == THUMB) {
            if(paused) {
              histo.announce(PLAYBACK_EVENT, PLAY)
            } else {
              histo.announce(PLAYBACK_EVENT, PAUSE)
            }
            paused = !paused
          }
        } else {}
      } else {}
      if(!paused) {
        histo.announce(PLAYBACK_EVENT, PLAY)
      }
      dragged = false;
      mouseIsDown = false
    }
    function clearAll() {
      thumbColor.setTarget(180)
    }
    function handleSelect(params) {
      if(params.item) {
        setSeries(params.item, params.label)
      } else {
        setSeries(total)
      }
    }
    var histo = {
      draw: draw,
      setData: setData,
      setSecond: setSecond,
      handleSelect: handleSelect,
      bind: bind
    };
    F.eventify(histo);
    app.histo = histo
  }
  )(window.app);
  "use strict";
  (function(app) {
    var constants = app.constants, canvas, ctx, $label = $("#group-name"), GROUP_LEGEND_UNHIGHLIGHT_ALPHA = 0.8, SUBGROUP_LABELS = constants.SUBGROUP_LABELS, DEFAULT_LABEL = "Guide", TAU = Math.PI * 2, round = Math.round, floor = Math.floor, abs = Math.abs, cos = Math.cos, sin = Math.sin, atan2 = Math.atan2, sqrt = Math.sqrt, groups, items, W, H, cx, cy, looping = false, labelText = "", labelSetHandle = false, labelNext = null;
    var INNERMOST_RADIUS = 10
    , CENTER_RADIUS = 22.5
    , OUTERMOST_RADIUS = 35
    , SELECT_EVENT = constants.SELECT_EVENT
    , HOVER = constants.HOVER
    , LOCK = constants.LOCK
    , CLEAR = constants.CLEAR
    , GROUP = constants.GROUP
    , GRAVITRON = constants.GRAVITRON;
    function GroupItem(group, name, innerRadius, outerRadius, startAngle, endAngle) {
      this.group = group;
      this.name = name;
      this.width = new F.SoftFloat(1);
      this.alpha = new F.SoftFloat(0);
      this.startAngle = startAngle;
      this.endAngle = endAngle;
      this.outerRadius = outerRadius;
      this.outerRadiusSquared = outerRadius * outerRadius;
      this.innerRadius = innerRadius;
      this.maxWidth = (outerRadius - innerRadius) / 2;
      this.unitVectors = arc(outerRadius, startAngle, endAngle - startAngle);
      this.minWidth = name == "Payer" ? 1.35 : 1.25;
      this.radius = (outerRadius + innerRadius) / 2;
      this.highlighted = false;
      var rgb = group.rgb;
      this.rgbString = "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ","
    }
    GroupItem.prototype.highlight = function() {
      this.alpha.setTarget(1);
      this.width.setTarget(this.maxWidth);
      this.highlighted = true;
      setLabel(this.name)
    }
    ;
    GroupItem.prototype.unhighlight = function() {
      if(this.highlighted) {
        this.highlighted = false;
        this.alpha.setTarget(GROUP_LEGEND_UNHIGHLIGHT_ALPHA);
        this.width.setTarget(this.minWidth)
      }
    }
    ;
    GroupItem.prototype.draw = function(ctx) {
      var alpha = this.alpha
      , width = this.width;
      alpha.update();
      width.update();
      ctx.fillStyle = this.rgbString + (round(alpha.get() * 100) / 100) + ")";
      ctx.beginPath();
      this.drawShape(ctx);
      ctx.fill();
      return (alpha.atTarget && width.atTarget)
    }
    ;
    GroupItem.prototype.drawShape = function(ctx) {
      var r = this.radius
      , w = this.width.get();
      this.traceArcs(ctx, this.unitVectors, r + w, r - w)
    }
    ;
    GroupItem.prototype.traceArcs = function(ctx, unitVectors, r1, r2) {
      var i, L = unitVectors.length, point = unitVectors[0];
      ctx.moveTo(cx + point[0] * r1, cy + point[1] * r1);
      ctx.arc(cx, cy, r1, this.startAngle, this.endAngle, false);
      if(r2 > 0) {
        ctx.arc(cx, cy, r2, this.endAngle, this.startAngle, true)
      }
    }
    ;
    function init() {
      canvas = $("#legend")[0];
      ctx = canvas.getContext("2d");
      W = $(canvas).width();
      H = $(canvas).height();
      $(canvas).width(W);
      $(canvas).height(H);
      cx = W * 0.5;
      cy = H * 0.5;
      if(window.devicePixelRatio > 1) {
        canvas.width = W * window.devicePixelRatio;
        canvas.height = H * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio)
      } else {
        canvas.width = W;
        canvas.height = H
      }
      $label.removeClass("active")
    }
    function bind() {
      $(canvas).bind("mousemove", handleMouseMove);
      $(canvas).bind("mousedown", handleMouseDown)
    }
    function handleMouseMove(eventData) {
      eventData.stopPropagation();
      var item = getMousedItem(eventData);
      if(item) {
        var label = item.group.name;
        $(canvas).addClass("hover");
        legend.announce(SELECT_EVENT, {
          type: GROUP,
          action: HOVER,
          item: item.group,
          label: label
        })
      } else {
        $(canvas).removeClass("hover");
        legend.announce(SELECT_EVENT, {
          type: CLEAR,
          action: HOVER,
          item: false
        })
      }
    }
    function getMousedItem(eventData) {
      var dx = eventData.offsetX - cx
      , dy = eventData.offsetY - cy
      , d2 = dx * dx + dy * dy
      , d = sqrt(d2)
      , angle = atan2(dy, dx)
      , item = false;
      if(angle < -TAU / 12 * 5) {
        angle += TAU
      }
      if(d <= OUTERMOST_RADIUS) {
        if(d <= CENTER_RADIUS) {
          if(d <= INNERMOST_RADIUS) {
            item = items[4]
          } else {
            for(var i = 5, L = items.length; i < L; i++) {
              item = items[i];
              if(angle >= item.startAngle && angle <= item.endAngle) {
                break
              }
            }
          }
        } else {
          for(var i = 1; i < 4; i++) {
            item = items[i];
            if(angle >= item.startAngle && angle <= item.endAngle) {
              break
            }
          }
        }
      }
      return item
    }
    function handleMouseDown(eventData) {
      eventData.stopPropagation();
      var item = getMousedItem(eventData);
      if(item) {
        legend.announce(SELECT_EVENT, {
          type: GROUP,
          action: LOCK,
          item: item.group
        })
      }
    }
    function setSelectedGroup(group) {
      if(!group) {
        for(var i = 1, L = items.length; i < L; i++) {
          items[i].unhighlight()
        }
      } else {
        if(group.groupId == 0) {
          for(var i = 1; i < 4; i++) {
            items[i].unhighlight()
          }
          for(var i = 4, L = items.length; i < L; i++) {
            items[i].highlight()
          }
          setLabel("Practice")
        } else {
          for(var i = 1, L = items.length; i < L; i++) {
            items[i].unhighlight()
          }
          items[group.groupId].highlight()
        }
      }
    }
    function handleSelect(params) {
      if(params.type === GROUP) {
        setSelectedGroup(params.item)
      } else {
        if(params.type === GRAVITRON) {
          setSelectedNode(params.item)
        } else {
          if(params.type === CLEAR) {
            setSelectedNode(false);
            for(var i = items.length - 1; i > 0; i--) {
              items[i].unhighlight();
              items[i].alpha.setTarget(GROUP_LEGEND_UNHIGHLIGHT_ALPHA);
              items[i].width.setTarget(items[i].minWidth)
            }
          }
        }
      }
    }
    function setSelectedGroupId(groupId) {
      for(var i = items.length - 1; i > 0; i--) {
        items[i].unhighlight()
      }
      items[groupId].highlight()
    }
    function setSelectedNode(node) {
      if(node) {
        if(node.groupId > 0) {
          setSelectedGroupId(node.groupId)
        } else {
          var id = SUBGROUP_LABELS.indexOf(node.subtype);
          setSelectedGroupId(id + 4)
        }
      } else {
        setSelectedGroup(false);
        setLabel(DEFAULT_LABEL)
      }
    }
    function setData(data) {
      groups = data.groups;
      items = [];
      var startAngle = -TAU / 12 * 5;
      var endAngle = startAngle + TAU / 3;
      var practice = groups[0];
      var centerItem = new GroupItem(practice.arcs[0],"Practice Encounter",0,INNERMOST_RADIUS,0,TAU);
      centerItem.radius = centerItem.outerRadius;
      centerItem.drawShape = function(ctx) {
        var r = this.radius
        , w = this.width.get();
        this.traceArcs(ctx, this.unitVectors, r, r - w * 2)
      }
      ;
      for(var i = 1, L = groups.length; i < L; i++) {
        var group = groups[i];
        items[i] = new GroupItem(group,group.name,CENTER_RADIUS,OUTERMOST_RADIUS,startAngle,endAngle);
        startAngle = endAngle;
        endAngle += TAU / 3
      }
      items[4] = centerItem;
      for(var i = 1, L = groups.length; i < L; i++) {
        var subGroup = practice.arcs[i];
        var echoItem = items[i];
        items[i + 4] = new GroupItem(subGroup,subGroup.name,INNERMOST_RADIUS,CENTER_RADIUS,echoItem.startAngle,echoItem.endAngle)
      }
      labelNext = null;
      launchLoop()
    }
    function setSpeedParams(speedo) {
      var widthFloat;
      if(!items) {
        return
      }
      for(var i = 1, L = items.length; i < L; i++) {
        widthFloat = items[i].width;
        widthFloat.attraction = speedo.attraction;
        widthFloat.damping = speedo.damping
      }
    }
    function setLabel(text) {
      if(labelText == text) {} else {
        if(labelText == "") {
          $label.text(text);
          $label.addClass(labelText == DEFAULT_LABEL ? "active-default" : "active");
          labelText = text
        } else {
          if(text == "") {
            labelNext = "";
            if($label.hasClass("active") || $label.hasClass("active-default")) {
              if(labelSetHandle) {
                clearTimeout(labelSetHandle)
              }
              $label.removeClass("active");
              $label.removeClass("active-default")
            }
          } else {
            labelNext = text;
            if($label.hasClass("active") || $label.hasClass("active-default")) {
              $label.removeClass("active");
              $label.removeClass("active-default");
              if(labelSetHandle) {
                clearTimeout(labelSetHandle)
              }
              labelSetHandle = setTimeout(function() {
                labelText = labelNext;
                $label.text(labelText);
                $label.addClass(labelText == DEFAULT_LABEL ? "active-default" : "active");
                labelSetHandle = false
              }, 250)
            } else {
              labelText = labelNext;
              $label.text(labelText);
              $label.addClass(labelText == DEFAULT_LABEL ? "active-default" : "active")
            }
          }
        }
      }
    }
    function launchLoop() {
      if(!looping) {
        requestFrame()
      }
    }
    function requestFrame() {
      requestAnimationFrame(draw)
    }
    function draw() {
      looping = true;
      var n = Date.now() + 20;
      ctx.clearRect(0, 0, W, H);
      for(var i = 1, L = items.length; i < L; i++) {
        items[i].draw(ctx)
      }
      n -= Date.now();
      if(n <= 0) {
        n = 1
      }
      setTimeout(requestFrame, n)
    }
    init();
    function arc(radius, angleStart, angleSpan) {
      var vertices = []
      , circumference = radius * angleSpan
      , outerStepCount = floor(circumference);
      for(var i = 0; i <= outerStepCount; i++) {
        var amt = i / outerStepCount * angleSpan;
        vertices.push([cos(angleStart + amt), sin(angleStart + amt)])
      }
      return vertices
    }
    var legend = {
      bind: bind,
      handleSelect: handleSelect,
      setData: setData,
      setSpeedParams: setSpeedParams
    };
    F.eventify(legend);
    app.legend = legend
  }
  )(window.app);
  "use strict";
  (function(app) {
    var constants = app.constants, glCanvas, centers, centerLookup, boundingNode, groups, arcs, W, H, headerHeight, cx, cy, tx, ty, tzoom, extraDrawer = function() {}, updateGravitrons = function() {}, nodeUpdateFunction = function() {}, pow = Math.pow, TAU = Math.PI * 2, abs = Math.abs, round = Math.round, BASE_ZOOM = 1, BASE_W, BASE_H, baseCx, baseCy, zoom = new F.SoftFloat(1), panX = new F.SoftFloat(0), panY = new F.SoftFloat(0), t, dragging = false, dragged = false, startX, startY, panStartX, panStartY, mousedNode = false, lockedNode = false, mousedGroup = false, lockedGroup = false, DRAG_THRESHHOLD_SQUARED = constants.DRAG_THRESHHOLD_SQUARED, ZOOM_PAN_EVENT = constants.ZOOM_PAN_EVENT, MIN_ZOOM = constants.MIN_ZOOM, MAX_ZOOM = constants.MAX_ZOOM, BOTTOM_RIGHT = TAU * (1 / 4 - 1 / 128), BOTTOM_LEFT = TAU * (1 / 4 + 1 / 128), TOP_LEFT = TAU * (3 / 4 - 1 / 128), TOP_RIGHT = TAU * (3 / 4 + 1 / 128), RIGHT = 1, BOTTOM = 2, LEFT = 3, TOP = 4, HOVER = constants.HOVER, LOCK = constants.LOCK, CLEAR = constants.CLEAR, GROUP = constants.GROUP, GRAVITRON = constants.GRAVITRON, SELECT_EVENT = constants.SELECT_EVENT, FPS = 30, FRAMEDELAY = Math.floor(1000 / FPS) - 4, nowF = Date.now, nextFtime, launchtime = -1, frameCount = 0, elapsed = 0, totalCount, lerperCount, faderCount, $totalCount = $("#total-count"), $lerperCount = $("#lerper-count"), $faderCount = $("#fader-count"), $fps = $("#fps"), commify = F.NumberLabeler.commify, tooOld, frametimes = [], focusRect = false, mx, my, tmx, tmy, tCx, tCy, drawingParticles = true, drawParticles = false, drawLaunched = false;
    function init() {
      glCanvas = $("#particles")[0];
      particulate.announce(constants.SHARE_CONTROL_EVENT, {
        zoom: zoom,
        panX: panX,
        panY: panY
      })
    }
    function setSize(sizes) {
      W = sizes.width;
      H = sizes.height;
      headerHeight = sizes.headerHeight;
      $("#main").width(W);
      $("#main").height(H);
      $(glCanvas).width(W);
      $(glCanvas).height(H);
      cx = W * 0.5;
      cy = H * 0.5;
      baseCx = cx;
      baseCy = cy;
      if(window.devicePixelRatio > 1) {
        BASE_ZOOM = window.devicePixelRatio;
        zoom.set(BASE_ZOOM);
        BASE_W = W * BASE_ZOOM;
        BASE_H = H * BASE_ZOOM;
        baseCx = cx * BASE_ZOOM;
        baseCy = cy * BASE_ZOOM
      } else {
        BASE_W = W;
        BASE_H = H
      }
      glCanvas.width = BASE_W;
      glCanvas.height = BASE_H;
      if(groups) {
        for(var i = 0, L = groups.length; i < L; i++) {
          groups[i].position(cx, cy)
        }
        boundingNode = groups[1].centers[0]
      }
    }
    function bind() {
      $(glCanvas).bind("mousemove", handleMouseMove);
      $(glCanvas).bind("mousedown", handleMouseDown);
      $(glCanvas).bind("mouseup", handleMouseUp);
      updateGravitrons = updateGravitronUnchecked
    }
    function setData(data) {
      centers = data.centers;
      groups = data.groups;
      arcs = groups[0].arcs.concat(groups.slice(1));
      centerLookup = data.centerLookup;
      if(W) {
        for(var i = 0, L = groups.length; i < L; i++) {
          groups[i].position(cx, cy)
        }
        boundingNode = groups[1].centers[0]
      }
      if(!drawLaunched) {
        drawLaunched = true;
        draw()
      }
    }
    function setUpdater(params) {
      nodeUpdateFunction = params.updater;
      if(params.extraDrawer) {
        extraDrawer = params.extraDrawer
      } else {
        extraDrawer = function() {}
      }
      if(params.nodeFunction) {
        updateGravitrons = params.nodeFunction
      } else {
        launchtime = Date.now()
      }
    }
    function setFocus(rect) {
      if(rect) {
        var w = rect.right - rect.left
        , h = rect.bottom - rect.top
        , widthCoefficient = W / w
        , heightCoefficient = H / h
        , z = (widthCoefficient < heightCoefficient ? widthCoefficient : heightCoefficient) * 0.75
        , rectCenterX = (rect.right + rect.left) / 2
        , rectCenterY = (rect.bottom + rect.top) / 2
        , dx = cx - rectCenterX
        , dy = cy - rectCenterY;
        if(z > MAX_ZOOM) {
          z = MAX_ZOOM
        } else {
          if(z < MIN_ZOOM) {
            z = MIN_ZOOM
          }
        }
        focusRect = rect;
        particulate.announce(ZOOM_PAN_EVENT, {
          zoom: z,
          panX: dx * z,
          panY: dy * z
        })
      } else {
        particulate.announce(ZOOM_PAN_EVENT, {
          zoom_adjustment: constants.RESET_ZOOM_PAN
        })
      }
    }
    function setZoomPan(zoomPanData) {
      if(zoomPanData.zoom) {
        zoom.setTarget(BASE_ZOOM * zoomPanData.zoom)
      }
      if(zoomPanData.panX != undefined) {
        panX.setTarget(BASE_ZOOM * zoomPanData.panX)
      }
      if(zoomPanData.panY != undefined) {
        panY.setTarget(BASE_ZOOM * zoomPanData.panY)
      }
    }
    function getTranslatedXY(eventData) {
      var x = eventData.offsetX
      , y = eventData.offsetY
      , dx = x - cx
      , dy = y - cy
      , ltx = cx + dx / tzoom * BASE_ZOOM - tx / tzoom
      , lty = cy + dy / tzoom * BASE_ZOOM - ty / tzoom;
      return [ltx, lty]
    }
    function getUntranslatedXY(ltx, lty) {
      var tdx = ltx + tx / tzoom - cx
      , tdy = lty + ty / tzoom - cy
      , dx = tdx / BASE_ZOOM * tzoom
      , dy = tdy / BASE_ZOOM * tzoom
      , x = dx + cx
      , y = dy + cy;
      return [x, y]
    }
    function updateZoomPan() {
      zoom.update();
      panX.update();
      panY.update();
      tzoom = zoom.get();
      var zw = W * tzoom
      , zh = H * tzoom
      , zCx = zw * 0.5
      , zCy = zh * 0.5;
      tCx = baseCx - zCx;
      tCy = baseCy - zCy;
      tx = panX.get(),
      ty = panY.get()
    }
    function getClosestNode(mx, my) {
      var node, d2, closestNode = false, minD2 = 25 * 25, s2, dx, dy;
      for(var i = centers.length - 1; i >= 0; i--) {
        node = centers[i];
        s2 = node.size.get();
        s2 *= s2;
        dx = mx - node.x;
        dy = my - node.y;
        d2 = dx * dx + dy * dy;
        if(d2 < s2) {
          closestNode = node;
          break
        }
        if(d2 < minD2) {
          minD2 = d2;
          closestNode = node
        }
      }
      return closestNode
    }
    function updateGravitronUnchecked() {
      centers.forEach(updateGravitron)
    }
    function updateGravitron(g, i) {
      g.updateTargets();
      g.updateValues();
      var gx = g.x
      , gy = g.y
      , coords = getUntranslatedXY(gx, gy)
      , labelX = coords[0]
      , labelY = coords[1]
      , groupAngle = g.groupAngle
      , s = g.size.get() * 2 * zoom.get() + 5
      , labelWidth = g.labelWidth
      , labelHeight = g.labelHeight;
      while (groupAngle < 0) {
        groupAngle += TAU
      }
      if(groupAngle < TOP_RIGHT) {
        if(groupAngle < TOP_LEFT) {
          if(groupAngle < BOTTOM_LEFT) {
            if(groupAngle < BOTTOM_RIGHT) {
              g.labelSide = RIGHT;
              labelX += s;
              labelY -= 4
            } else {
              g.labelSide = BOTTOM;
              labelX -= labelWidth / 2;
              labelY += s
            }
          } else {
            g.labelSide = LEFT;
            labelX -= s + g.getLabelWidth() + 10;
            labelY -= labelHeight * 0.5
          }
        } else {
          g.labelSide = TOP;
          labelY -= s + labelHeight;
          labelX -= labelWidth / 2
        }
      } else {
        g.labelSide = RIGHT;
        labelX += s;
        labelY -= labelHeight * 0.5
      }
      if(labelX < 0) {
        labelX = coords[0] + s
      } else {
        if(labelX > W - labelWidth) {
          labelX = coords[0] - s - 10 - g.getLabelWidth()
        }
      }
      if(labelY < headerHeight) {
        labelY = coords[1] + s
      } else {
        if(labelY > H - headerHeight) {
          labelY = coords[1] - s
        }
      }
      g.positionLabel(labelX, labelY);
      lerperCount += g.movingCount;
      faderCount += g.fadingCount;
      totalCount += g.movingCount + g.fadingCount
    }
    function unoverlapLabels(arc) {
      var gravs = arc.centers, L = gravs.length, maxX = -100000, minX = 100000, rightMost = -1, leftMost = -1, grav, x, y, side, priorY, labelY, priorLabelY, h, priorH, gx;
      for(var i = 0; i < L; i++) {
        grav = gravs[i];
        x = grav.x;
        side = grav.labelSide;
        if(x < minX && side != RIGHT) {
          minX = x;
          leftMost = i
        }
        if(x > maxX && side != LEFT) {
          maxX = x;
          rightMost = i
        }
      }
      if(rightMost >= 0) {
        grav = gravs[rightMost];
        priorY = grav.labelY;
        priorLabelY = priorY;
        priorH = grav.getLabelHeight() + 6;
        for(var i = rightMost - 1; i >= 0; i--) {
          grav = gravs[i];
          if(grav.labelSide == LEFT) {
            break
          }
          y = grav.labelY;
          labelY = y;
          h = grav.getLabelHeight() + 6;
          if(y > priorLabelY - h) {
            labelY = priorLabelY - h;
            gx = grav.labelX;
            if(grav.labelSide == RIGHT && grav.labelX > grav.x) {
              gx = grav.x
            }
            grav.positionLabel(gx, labelY)
          }
          priorY = y;
          priorLabelY = labelY;
          priorH = h
        }
        grav = gravs[rightMost];
        priorY = grav.labelY;
        priorLabelY = priorY;
        priorH = grav.getLabelHeight() + 6;
        for(var i = rightMost + 1; i < L; i++) {
          grav = gravs[i];
          if(grav.labelSide == LEFT) {
            break
          }
          y = grav.labelY;
          labelY = y;
          h = grav.getLabelHeight() + 6;
          if(y < priorLabelY + priorH) {
            labelY = priorLabelY + priorH;
            gx = grav.labelX;
            if(grav.labelSide == RIGHT && grav.labelX > grav.x) {
              gx = grav.x
            }
            grav.positionLabel(gx, labelY)
          }
          priorY = y;
          priorLabelY = labelY;
          priorH = h
        }
      }
      if(leftMost >= 0) {
        grav = gravs[leftMost];
        priorY = grav.labelY;
        priorLabelY = priorY;
        priorH = grav.getLabelHeight() + 6;
        for(var i = leftMost + 1; i < L; i++) {
          grav = gravs[i];
          if(grav.labelSide == RIGHT) {
            break
          }
          y = grav.labelY;
          labelY = y;
          h = grav.getLabelHeight() + 6;
          if(y > priorLabelY - h) {
            labelY = priorLabelY - h;
            grav.positionLabel(grav.labelX, labelY)
          }
          priorY = y;
          priorLabelY = labelY;
          priorH = h
        }
        grav = gravs[leftMost];
        priorY = grav.labelY;
        priorLabelY = priorY;
        priorH = grav.getLabelHeight() + 6;
        for(var i = leftMost - 1; i >= 0; i--) {
          grav = gravs[i];
          if(grav.labelSide == RIGHT) {
            break
          }
          y = grav.labelY;
          labelY = y;
          h = grav.getLabelHeight() + 6;
          if(y < priorLabelY + priorH) {
            labelY = priorLabelY + priorH;
            grav.positionLabel(grav.labelX, labelY)
          }
          priorY = y;
          priorLabelY = labelY;
          priorH = h
        }
      }
    }
    function draw() {
      t = nowF();
      totalCount = 0;
      lerperCount = 0;
      faderCount = 0;
      nodeUpdateFunction();
      updateZoomPan();
      updateGravitrons();
      if(drawParticles) {
        drawParticles()
      }
      extraDrawer();
      if(lockedNode) {
        lockedNode.highlight();
        if(mousedNode && mousedNode != lockedNode) {
          mousedNode.highlight()
        }
      } else {
        if(mousedNode) {
          mousedNode.highlight()
        }
      }
      nextFtime = t + FRAMEDELAY;
      t = nowF();
      if(t > nextFtime) {
        requestFrame()
      } else {
        setTimeout(requestFrame, nextFtime - t)
      }
    }
    function requestFrame() {
      requestAnimationFrame(draw)
    }
    function handleMouseMove(eventData) {
      eventData.stopPropagation();
      mx = eventData.offsetX;
      my = eventData.offsetY;
      var tc = getTranslatedXY(eventData);
      tmx = tc[0];
      tmy = tc[1];
      if(dragging) {
        var dx = eventData.offsetX - startX
        , dy = eventData.offsetY - startY;
        if(dragged || dx * dx + dy * dy >= DRAG_THRESHHOLD_SQUARED) {
          dragged = true;
          var panX = panStartX / BASE_ZOOM + dx
          , panY = panStartY / BASE_ZOOM + dy
          , panLimit = boundingNode.distance * tzoom;
          if(panX < -panLimit) {
            panX = -panLimit
          } else {
            if(panX > panLimit) {
              panX = panLimit
            }
          }
          if(panY < -panLimit) {
            panY = -panLimit
          } else {
            if(panY > panLimit) {
              panY = panLimit
            }
          }
          particulate.announce(ZOOM_PAN_EVENT, {
            panX: panX,
            panY: panY
          })
        }
      } else {
        var coords = getTranslatedXY(eventData)
        , closestNode = getClosestNode(coords[0], coords[1]);
        if((mousedNode != closestNode) || mousedGroup) {
          particulate.announce(constants.SELECT_EVENT, {
            type: GRAVITRON,
            action: HOVER,
            item: closestNode
          })
        }
        if(closestNode) {
          $(glCanvas).addClass("hover")
        } else {
          $(glCanvas).removeClass("hover")
        }
      }
    }
    function handleMouseDown(eventData) {
      eventData.stopPropagation();
      startX = eventData.offsetX;
      startY = eventData.offsetY;
      panStartX = panX.get();
      panStartY = panY.get();
      var coords = getTranslatedXY(eventData);
      mousedNode = getClosestNode(coords[0], coords[1]);
      dragging = true
    }
    function handleMouseUp(eventData) {
      eventData.stopPropagation();
      if(!dragged) {
        particulate.announce(constants.SELECT_EVENT, {
          type: GRAVITRON,
          action: LOCK,
          item: mousedNode
        })
      } else {
        dragged = false
      }
      dragging = false
    }
    function handleSelect(params) {
      if(params.type == GRAVITRON) {
        if(params.action == HOVER) {
          mousedNode = params.item
        } else {
          if(params.action == LOCK) {
            lockedNode = params.item
          }
        }
      } else {
        if(params.type == GROUP) {
          if(params.action == HOVER) {
            mousedGroup = params.item
          } else {
            if(params.action == LOCK) {
              lockedGroup = params.item
            }
          }
        } else {
          if(params.type == CLEAR) {
            if(params.action == HOVER) {
              mousedNode = false
            } else {
              if(params.action == LOCK) {
                lockedNode = false
              }
            }
          }
        }
      }
    }
    function setParticleFunction(data) {
      if(data.status == constants.READY) {
        drawParticles = data.drawFunction;
        drawingParticles = true
      }
    }
    var particulate = {
      bind: bind,
      setZoomPan: setZoomPan,
      setFocus: setFocus,
      setData: setData,
      setSize: setSize,
      setUpdater: setUpdater,
      handleSelect: handleSelect,
      setParticleFunction: setParticleFunction,
      init: init
    };
    F.eventify(particulate);
    app.particulate = particulate
  }
  )(window.app);
  "use strict";
  (function(app) {
    var constants = app.constants
    , $container = $("#zoom-controls")
    , $zoomin = $("#z-in")
    , $zoomout = $("#z-out")
    , $reset = $("#z-set")
    , ZOOM_IN = constants.ZOOM_IN
    , ZOOM_OUT = constants.ZOOM_OUT
    , RESET = constants.RESET_ZOOM_PAN
    , MIN_ZOOM = constants.MIN_ZOOM
    , MAX_ZOOM = constants.MAX_ZOOM
    , DEFAULT_ZOOM = constants.DEFAULT_ZOOM
    , UNSCALED_TARGET_HEIGHT = 933
    , currentZoom = DEFAULT_ZOOM;
    var zoom = 1
    , panX = 0
    , panY = 0;
    function bind() {
      $container.removeClass("inactive");
      $zoomin.bind("mousedown", zoomIn);
      $zoomout.bind("mousedown", zoomOut);
      $reset.bind("mousedown", reset);
      $("#zoom-controls").bind("mousemove", function(e) {
        e.stopPropagation()
      })
    }
    function zoomIn(e) {
      e.stopPropagation();
      setZoomPan({
        zoom_adjustment: ZOOM_IN
      })
    }
    function zoomOut(e) {
      e.stopPropagation();
      setZoomPan({
        zoom_adjustment: ZOOM_OUT
      })
    }
    function reset(e) {
      e.stopPropagation();
      zoomControls.announce(constants.ZOOM_RESET_EVENT)
    }
    function setSize(size) {
      var viewportHeight = size.height - size.headerHeight * 2;
      DEFAULT_ZOOM = (viewportHeight < size.width ? viewportHeight : size.width) / UNSCALED_TARGET_HEIGHT;
      constants.DEFAULT_ZOOM = DEFAULT_ZOOM;
      constants.MIN_ZOOM = DEFAULT_ZOOM * 0.25;
      constants.MAX_ZOOM = DEFAULT_ZOOM * 4
    }
    function setZoomPan(zp) {
      var params = {};
      if(zp.zoom_adjustment) {
        params.zoom_adjustment = zp.zoom_adjustment;
        switch (zp.zoom_adjustment) {
        case ZOOM_IN:
          zoom *= 1.25;
          params.zoom = zoom;
          break;
        case ZOOM_OUT:
          zoom /= 1.25;
          params.zoom = zoom;
          break;
        case RESET:
          zoom = DEFAULT_ZOOM;
          panX = 0;
          panY = 0;
          params.zoom = zoom;
          params.panX = panX;
          params.panY = panY;
          break
        }
      } else {
        if(zp.zoom) {
          zoom = zp.zoom;
          params.zoom = zp.zoom
        }
      }
      if(zp.panX !== undefined) {
        panX = zp.panX;
        params.panX = panX
      }
      if(zp.panY !== undefined) {
        panY = zp.panY;
        params.panY = panY
      }
      if(zoom >= MAX_ZOOM) {
        zoom = MAX_ZOOM;
        params.zoom = zoom;
        $zoomin.addClass("disabled")
      } else {
        $zoomin.removeClass("disabled")
      }
      if(zoom < MIN_ZOOM) {
        zoom = MIN_ZOOM;
        params.zoom = zoom;
        $zoomout.addClass("disabled")
      } else {
        $zoomout.removeClass("disabled")
      }
      if(zoom == DEFAULT_ZOOM && panX == 0 && panY == 0) {
        $container.removeClass("expanded")
      } else {
        $container.addClass("expanded")
      }
      currentZoom = zoom;
      zoomControls.announce(constants.ZOOM_PAN_EVENT, params)
    }
    var zoomControls = {
      bind: bind,
      setZoomPan: setZoomPan,
      setSize: setSize
    };
    F.eventify(zoomControls);
    app.zoomControls = zoomControls
  }
  )(window.app);
  (function(app) {
    var constants = app.constants, glCanvas, gl, shader, BASE_W, BASE_H, centers, maxCenterId, pow = Math.pow, PI = Math.PI, TAU = PI * 2, abs = Math.abs, sqrt = Math.sqrt, pow = Math.pow, hexture, gradients, updatingParticles = true, pathCount, pathFramebuffer, pathCenterLocationUniform, resolutionLocation, pathTextureRgba, pathRgbaIndices, paths, pathIndices, pathBuffer, pathIndicesAttribute, controlPoints, controlPointsBuffer, controlPointsAttribute, PATH_IMAGE_SIZE = 64, BAD_READING_SIZE = 256 * 256 - 1, TRAVEL_PIXELS = constants.TRAVEL_PIXELS, PATH_TYPES = constants.PATH_TYPES, buffIt, badReadingCount = 0;
    function init(igloo, glContext, buffItFunction, createAndSetupTexture, gradientImage) {
      gl = glContext;
      var vertSrc = $("#pathlength-vs").text();
      var fragSrc = $("#pathlength-fs").text();
      shader = igloo.program(vertSrc, fragSrc).program;
      app.pathShader.shader = shader;
      buffIt = buffItFunction;
      var pathGradients = createAndSetupTexture(gl, gl.NEAREST, gl.NEAREST);
      gl.useProgram(shader);
      gl.bindTexture(gl.TEXTURE_2D, pathGradients);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, gradientImage);
      initGlBuffers(createAndSetupTexture)
    }
    function initGlBuffers(createAndSetupTexture) {
      gl.useProgram(shader);
      resolutionLocation = gl.getUniformLocation(shader, "resolution");
      pathCenterLocationUniform = gl.getUniformLocation(shader, "centerLocation");
      var pixels = new Uint8Array(PATH_IMAGE_SIZE * PATH_IMAGE_SIZE * 4);
      var pathTexture = createAndSetupTexture(gl, gl.NEAREST, gl.NEAREST);
      gl.activeTexture(gl.TEXTURE0);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, PATH_IMAGE_SIZE, PATH_IMAGE_SIZE, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      pathFramebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, pathFramebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pathTexture, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null)
    }
    function setSize(W, H, BW, BH) {
      BASE_W = BW;
      BASE_H = BH;
      if(shader) {
        gl.useProgram(shader);
        gl.uniform2f(resolutionLocation, PATH_IMAGE_SIZE / 2, PATH_IMAGE_SIZE / 2)
      }
    }
    function setData(centers, maxCenterId) {
      pathCount = 0;
      pathIndices = [];
      paths = [];
      pathRgbaIndices = [];
      pathTextureRgba = new Uint8Array(PATH_IMAGE_SIZE * PATH_IMAGE_SIZE * 4);
      controlPoints = [];
      var nonPracticeAngles = [], cn, ca, centerAngles = [];
      for(var i = 0; i <= maxCenterId; i++) {
        cn = centers[i];
        if(cn.groupId > 0) {
          ca = cn.groupAngle;
          if(ca < TAU * 0.25) {
            ca += TAU
          }
          nonPracticeAngles.push([cn.id, ca])
        }
        centerAngles[cn.id] = cn.groupAngle
      }
      nonPracticeAngles.sort(function(a, b) {
        if(a[1] < b[1]) {
          return -1
        }
        if(a[1] > b[1]) {
          return 1
        }
        return 0
      });
      var nonPracticeAngleCount = nonPracticeAngles.length, angleIncr = TAU / (nonPracticeAngleCount + 3), a = TAU * 0.25 + angleIncr * 0.5, mId;
      for(var i = 0; i < nonPracticeAngleCount; i++) {
        mId = nonPracticeAngles[i][0];
        centerAngles[mId] = a;
        a += angleIncr
      }
      var centerPaths, path, oIndex, dIndex, pathType, clockwise, rgbaIndex;
      for(var i = 0; i <= maxCenterId; i++) {
        centerPaths = centers[i].paths;
        for(var p = 0, L = centerPaths.length; p < L; p++) {
          path = centerPaths[p];
          oIndex = path.origin.id;
          dIndex = path.destination.id;
          pathType = path.pathType;
          var angle = centerAngles[dIndex] - centerAngles[oIndex];
          while (angle < -PI) {
            angle += TAU
          }
          while (angle > PI) {
            angle -= TAU
          }
          clockwise = angle > 0 ? 1 : 0;
          path.clockwise = clockwise;
          rgbaIndex = ((dIndex) * PATH_IMAGE_SIZE + (oIndex)) * 4;
          pathIndices.push(oIndex);
          pathIndices.push(dIndex);
          pathIndices.push(pathType);
          pathIndices.push(clockwise);
          if(pathType == PATH_TYPES.BEZIER) {
            var cp = path.controlData;
            controlPoints.push(cp[0]);
            controlPoints.push(cp[1]);
            controlPoints.push(cp[2]);
            controlPoints.push(cp[3])
          } else {
            controlPoints.push(0);
            controlPoints.push(0);
            controlPoints.push(0);
            controlPoints.push(0)
          }
          paths.push(path);
          pathRgbaIndices.push(rgbaIndex);
          pathCount++
        }
      }
      gl.useProgram(shader);
      pathIndices = new Float32Array(pathIndices);
      pathIndicesAttribute = gl.getAttribLocation(shader, "pathData");
      gl.enableVertexAttribArray(pathIndicesAttribute);
      pathBuffer = gl.createBuffer();
      buffIt(pathBuffer, pathIndicesAttribute, pathIndices, 4);
      controlPoints = new Float32Array(controlPoints);
      controlPointsAttribute = gl.getAttribLocation(shader, "controlPoints");
      gl.enableVertexAttribArray(controlPointsAttribute);
      controlPointsBuffer = gl.createBuffer();
      buffIt(controlPointsBuffer, controlPointsAttribute, controlPoints, 4)
    }
    function setLengths(centerLocationBuffer) {
      gl.useProgram(shader);
      buffIt(pathBuffer, pathIndicesAttribute, pathIndices, 4);
      buffIt(controlPointsBuffer, controlPointsAttribute, controlPoints, 4);
      gl.bindFramebuffer(gl.FRAMEBUFFER, pathFramebuffer);
      gl.uniform4fv(pathCenterLocationUniform, centerLocationBuffer);
      gl.viewport(0, 0, PATH_IMAGE_SIZE, PATH_IMAGE_SIZE);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.drawArrays(gl.POINTS, 0, pathCount);
      gl.readPixels(0, 0, PATH_IMAGE_SIZE, PATH_IMAGE_SIZE, gl.RGBA, gl.UNSIGNED_BYTE, pathTextureRgba);
      paths.forEach(setDistance);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null)
    }
    function setDistance(path, index) {
      var index = pathRgbaIndices[index];
      var d1 = pathTextureRgba[index]
      , d2 = pathTextureRgba[index + 1]
      , d = d1 + d2 * 256;
      if(d == BAD_READING_SIZE) {
        badReadingCount++;
        if(badReadingCount > 5000) {
          setDistance = function(path, index) {
            var d = getPathDistance(path.origin, path.destination);
            if(!d) {
              path.progressIncrement = 0.03
            } else {
              path.progressIncrement = TRAVEL_PIXELS / d
            }
            path.setLength(d)
          }
        }
        d = getPathDistance(path.origin, path.destination)
      }
      if(0 === d || isNaN(d)) {
        path.progressIncrement = 0.03
      } else {
        path.progressIncrement = TRAVEL_PIXELS / d
      }
      if(isNaN(path.progressIncrement)) {
        path.progressIncrement = 0.03
      }
      path.setLength(d)
    }
    function getPathDistance(origin, destination) {
      return sqrt(pow(destination.x - origin.x, 2) + pow(destination.y - origin.y, 2))
    }
    app.pathShader = {
      init: init,
      shader: null,
      setData: setData,
      setSize: setSize,
      setLengths: setLengths
    }
  }
  )(app);
  (function(app) {
    var constants = app.constants, MAX_PARTICLE_COUNT = constants.MAX_FADER_COUNT, gl, gravShader, centers, maxCenterId, W, H, BASE_W, BASE_H, TAU = Math.PI * 2, cos = Math.cos, sin = Math.sin, round = Math.round, hexData, hexColors, hexAlpha, buffIt, vertexPositions, vertexColors, vertexAlpha, vertexIndices, positionAttribLocation, positionBuffer, colorAttribLocation, colorBuffer, alphaAttribLocation, alphaBuffer, hexVertexIndexBuffer, resolutionUniform, matrix, VERTICES_PER_HEXAGON = 8, VERTEX_OFFSET = VERTICES_PER_HEXAGON * 2, VERTEX_ANGLES;
    function init(igloo, glContext, buffItFnc) {
      gl = glContext;
      buffIt = buffItFnc;
      var vertSrc = $("#gravitron-vs").text();
      var fragSrc = $("#gravitron-fs").text();
      gravShader = igloo.program(vertSrc, fragSrc).program;
      gl.useProgram(gravShader);
      initGlBuffers();
      app.gravitronShader.shader = gravShader
    }
    function initGlBuffers() {
      resolutionUniform = gl.getUniformLocation(gravShader, "resolution");
      matrixUniform = gl.getUniformLocation(gravShader, "matrix");
      positionAttribLocation = gl.getAttribLocation(gravShader, "grav_position");
      gl.enableVertexAttribArray(positionAttribLocation);
      colorAttribLocation = gl.getAttribLocation(gravShader, "grav_color");
      gl.enableVertexAttribArray(colorAttribLocation);
      alphaAttribLocation = gl.getAttribLocation(gravShader, "grav_alpha");
      gl.enableVertexAttribArray(alphaAttribLocation);
      positionBuffer = gl.createBuffer();
      colorBuffer = gl.createBuffer();
      alphaBuffer = gl.createBuffer();
      hexVertexIndexBuffer = gl.createBuffer()
    }
    function setSize(w, h, base_w, base_h) {
      W = w;
      H = h;
      BASE_W = base_w;
      BASE_H = base_h;
      if(gravShader) {
        gl.useProgram(gravShader);
        gl.uniform2f(resolutionUniform, W / 2, H / 2)
      }
    }
    function setData(_centers, _maxCenterId) {
      centers = _centers;
      maxCenterId = _maxCenterId;
      var vertexCount = centers.length * VERTICES_PER_HEXAGON;
      vertexPositions = new Float32Array(vertexCount * 2);
      vertexAlpha = new Float32Array(vertexCount);
      vertexColors = [];
      vertexIndices = [];
      var indexCount = 0
      , posIndex = 0;
      for(var c = 0; c <= maxCenterId; c++) {
        var center = centers[c]
        , rgb = center.parent.rgb
        , r = rgb[0]
        , g = rgb[1]
        , b = rgb[2];
        for(var i = 0; i < VERTICES_PER_HEXAGON; i++) {
          vertexColors.push(r);
          vertexColors.push(g);
          vertexColors.push(b);
          vertexIndices.push(indexCount);
          vertexAlpha[indexCount] = 1;
          vertexPositions[posIndex++] = W / 2;
          vertexPositions[posIndex++] = W / 2;
          indexCount++
        }
      }
      vertexColors = new Float32Array(vertexColors);
      vertexIndices = new Uint16Array(vertexIndices);
      VERTEX_ANGLES = [];
      var a, index = 0;
      VERTEX_ANGLES[index++] = 0;
      VERTEX_ANGLES[index++] = 0;
      for(var i = 0; i < VERTICES_PER_HEXAGON; i++) {
        a = i / 6 * TAU;
        VERTEX_ANGLES[index++] = round(cos(a) * 1000000) / 1000000;
        VERTEX_ANGLES[index++] = round(sin(a) * 1000000) / 1000000
      }
      gl.useProgram(gravShader);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, hexVertexIndexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, vertexIndices, gl.STATIC_DRAW)
    }
    function setNodeBufferValues(center) {
      var index = center.id * VERTICES_PER_HEXAGON
      , a = center.sparkleAlpha || 0
      , x = center.x
      , y = center.y
      , s = center.size.get()
      , alfIndex = index
      , posIndex = index * 2;
      vertexAlpha[alfIndex++] = a;
      vertexPositions[posIndex++] = x;
      vertexPositions[posIndex++] = y;
      for(var i = 1; i < VERTICES_PER_HEXAGON; i++) {
        vertexAlpha[alfIndex++] = a;
        vertexPositions[posIndex++] = x + VERTEX_ANGLES[i * 2] * s;
        vertexPositions[posIndex++] = y + VERTEX_ANGLES[i * 2 + 1] * s
      }
    }
    function drawNodes(mat3, zoom) {
      gl.useProgram(gravShader);
      centers.forEach(setNodeBufferValues);
      gl.uniformMatrix3fv(matrixUniform, false, mat3);
      buffIt(positionBuffer, positionAttribLocation, vertexPositions, 2);
      buffIt(colorBuffer, colorAttribLocation, vertexColors, 3);
      buffIt(alphaBuffer, alphaAttribLocation, vertexAlpha, 1);
      for(var i = 0, L = centers.length; i < L; i++) {
        gl.drawElements(gl.TRIANGLE_FAN, VERTICES_PER_HEXAGON, gl.UNSIGNED_SHORT, i * VERTEX_OFFSET)
      }
      firstFrame = false
    }
    app.gravitronShader = {
      init: init,
      shader: null,
      setSize: setSize,
      setData: setData,
      drawNodes: drawNodes
    }
  }
  )(app);
  (function(app) {
    var constants = app.constants, MAX_PARTICLE_COUNT = constants.MAX_LERPER_COUNT, BEZIER = constants.PATH_TYPES.BEZIER, gl, shader = false, pow = Math.pow, TAU = Math.PI * 2, abs = Math.abs, lerpParticles, lerpCount, hexture, gradients, updatingParticles = true, offsets, pathInfo, particleInfo, offsetAttribute, pathInfoAttribute, particleInfoAttribute, offsetBuffer, pathInfoBuffer, particleInfoBuffer, centerLocationUniform, centerLocationBuffer, centerGroupUniform, centerGroupBuffer, resolutionLocation, scaleUniform, matrixUniform, buffIt, particle, frameParticleCount, controlPoints, controlPointsAttribute, controlPointsBuffer;
    function init(igloo, glContext, buffItFnc, createAndSetupTexture, hextureImage, gradientImage) {
      gl = glContext;
      buffIt = buffItFnc;
      var vertSrc = $("#lerpers-vs").text();
      var fragSrc = $("#particle-fs").text();
      shader = igloo.program(vertSrc, fragSrc).program;
      gl.useProgram(shader);
      resolutionLocation = gl.getUniformLocation(shader, "resolution");
      centerLocationUniform = gl.getUniformLocation(shader, "centerLocation");
      centerGroupUniform = gl.getUniformLocation(shader, "centerGroup");
      centerGroupBuffer = new Float32Array(62);
      scaleUniform = gl.getUniformLocation(shader, "scale");
      matrixUniform = gl.getUniformLocation(shader, "matrix");
      initGlBuffers();
      setTextures(hextureImage, gradientImage, createAndSetupTexture);
      app.lerperShader.shader = shader
    }
    function initGlBuffers() {
      offsets = new Float32Array(2 * MAX_PARTICLE_COUNT);
      pathInfo = new Float32Array(MAX_PARTICLE_COUNT * 4);
      particleInfo = new Float32Array(MAX_PARTICLE_COUNT * 4);
      controlPoints = new Float32Array(MAX_PARTICLE_COUNT * 4);
      offsetAttribute = gl.getAttribLocation(shader, "offset");
      pathInfoAttribute = gl.getAttribLocation(shader, "pathInfo");
      particleInfoAttribute = gl.getAttribLocation(shader, "particleInfo");
      controlPointsAttribute = gl.getAttribLocation(shader, "controlPoints");
      gl.enableVertexAttribArray(offsetAttribute);
      gl.enableVertexAttribArray(pathInfoAttribute);
      gl.enableVertexAttribArray(particleInfoAttribute);
      gl.enableVertexAttribArray(controlPointsAttribute);
      offsetBuffer = gl.createBuffer();
      pathInfoBuffer = gl.createBuffer();
      particleInfoBuffer = gl.createBuffer();
      controlPointsBuffer = gl.createBuffer();
      gl.useProgram(shader);
      buffIt(offsetBuffer, offsetAttribute, offsets, 2);
      buffIt(pathInfoBuffer, pathInfoAttribute, pathInfo, 4);
      buffIt(particleInfoBuffer, particleInfoAttribute, particleInfo, 4);
      buffIt(controlPointsBuffer, controlPointsAttribute, controlPoints, 4)
    }
    function setTextures(hexImage, gradientImage, createAndSetupTexture) {
      gl.useProgram(shader);
      var hextureHandle = gl.getUniformLocation(shader, "hexture");
      gradients = createAndSetupTexture(gl, gl.NEAREST, gl.NEAREST);
      gl.bindTexture(gl.TEXTURE_2D, gradients);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, gradientImage);
      hexture = createAndSetupTexture(gl, gl.LINEAR, gl.LINEAR);
      gl.bindTexture(gl.TEXTURE_2D, hexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, hexImage);
      gl.uniform1i(hextureHandle, 1);
      gl.bindTexture(gl.TEXTURE_2D, gradients);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, hexture);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, hexture)
    }
    function setSize(W, H, BW, BH) {
      BASE_W = BW;
      BASE_H = BH;
      if(shader) {
        gl.useProgram(shader);
        gl.uniform2f(resolutionLocation, W, H)
      }
    }
    function setData(particles, centers) {
      lerpParticles = particles;
      lerpCount = lerpParticles.length;
      centerGroupBuffer = [];
      var c;
      for(var i = 0, L = centers.length; i < L; i++) {
        c = centers[i];
        centerGroupBuffer[c.id] = c.colorGroupId
      }
      centerGroupBuffer = new Float32Array(centerGroupBuffer)
    }
    function drawParticles(mat3, zoom, centerLocationBuffer) {
      var particle, path, controlData;
      frameParticleCount = 0;
      for(var i = 0; i < lerpCount; i++) {
        particle = lerpParticles[i];
        if(particle.complete || !particle.path) {} else {
          if(updatingParticles) {
            particle.update()
          }
          path = particle.path;
          offsets[frameParticleCount * 2] = particle.offset[0];
          offsets[frameParticleCount * 2 + 1] = particle.offset[1];
          pathInfo[frameParticleCount * 4] = particle.originId;
          pathInfo[frameParticleCount * 4 + 1] = particle.destinationId;
          pathInfo[frameParticleCount * 4 + 2] = path.pathType;
          pathInfo[frameParticleCount * 4 + 3] = path.clockwise;
          particleInfo[frameParticleCount * 4] = particle.progress || 0;
          particleInfo[frameParticleCount * 4 + 1] = particle.origin.defaultAlpha;
          particleInfo[frameParticleCount * 4 + 2] = path.scatter;
          particleInfo[frameParticleCount * 4 + 3] = particle.weight || 0.5;
          if(path.pathType == BEZIER) {
            controlData = path.controlData;
            controlPoints[frameParticleCount * 4] = controlData[0];
            controlPoints[frameParticleCount * 4 + 1] = controlData[1];
            controlPoints[frameParticleCount * 4 + 2] = controlData[2];
            controlPoints[frameParticleCount * 4 + 3] = controlData[3]
          }
          frameParticleCount++
        }
      }
      gl.useProgram(shader);
      gl.uniform1f(scaleUniform, zoom.get());
      gl.uniformMatrix3fv(matrixUniform, false, mat3);
      gl.uniform4fv(centerLocationUniform, centerLocationBuffer);
      gl.uniform1fv(centerGroupUniform, centerGroupBuffer);
      gl.uniform1fv;
      buffIt(offsetBuffer, offsetAttribute, offsets, 2);
      buffIt(pathInfoBuffer, pathInfoAttribute, pathInfo, 4);
      buffIt(particleInfoBuffer, particleInfoAttribute, particleInfo, 4);
      buffIt(controlPointsBuffer, controlPointsAttribute, controlPoints, 4);
      gl.drawArrays(gl.POINTS, 0, frameParticleCount)
    }
    function setUpdating(u) {
      updatingParticles = u
    }
    app.lerperShader = {
      init: init,
      shader: null,
      setSize: setSize,
      setData: setData,
      drawParticles: drawParticles,
      setUpdating: setUpdating
    }
  }
  )(app);
  (function(app) {
    var constants = app.constants, MAX_PARTICLE_COUNT = constants.MAX_FADER_COUNT, gl, shader, centers, maxCenterId, pow = Math.pow, TAU = Math.PI * 2, abs = Math.abs, particles, particleCount, hexture, gradients, updatingParticles = true, offset, originIndex, progress, direction, velocity, weight, alpha, offsetAttribute, originIndexAttribute, progressAttribute, directionAttribute, velocityAttribute, weightAttribute, alphaAttribute, offsetBuffer, originIndexBuffer, progressBuffer, directionBuffer, velocityBuffer, weightBuffer, alphaBuffer, centerLocationUniform, centerGroupUniform, centerGroupBuffer, resolutionLocation, scaleUniform, matrixUniform, buffIt, particle, frameParticleCount;
    function init(igloo, glContext, buffItFnc, createAndSetupTexture, hextureImage, gradientImage) {
      gl = glContext;
      buffIt = buffItFnc;
      shader = igloo.program("glsl/faders.vert", "glsl/particle.frag").program;
      gl.useProgram(shader);
      initGlBuffers();
      setTextures(hextureImage, gradientImage, createAndSetupTexture);
      app.faderShader.shader = shader
    }
    function initGlBuffers() {
      resolutionLocation = gl.getUniformLocation(shader, "resolution");
      centerLocationUniform = gl.getUniformLocation(shader, "centerLocation");
      centerGroupUniform = gl.getUniformLocation(shader, "centerGroup");
      centerGroupBuffer = new Float32Array(62);
      scaleUniform = gl.getUniformLocation(shader, "scale");
      matrixUniform = gl.getUniformLocation(shader, "matrix");
      var maxStepLocation = gl.getUniformLocation(shader, "MAX_STEP");
      gl.uniform1f(maxStepLocation, app.Fader.FADE_STEP_COUNT);
      offset = new Float32Array(2 * MAX_PARTICLE_COUNT);
      originIndex = new Float32Array(MAX_PARTICLE_COUNT);
      progress = new Float32Array(MAX_PARTICLE_COUNT);
      direction = new Float32Array(MAX_PARTICLE_COUNT);
      velocity = new Float32Array(MAX_PARTICLE_COUNT);
      weight = new Float32Array(MAX_PARTICLE_COUNT);
      alpha = new Float32Array(MAX_PARTICLE_COUNT);
      offsetAttribute = gl.getAttribLocation(shader, "offset");
      originIndexAttribute = gl.getAttribLocation(shader, "origin_index");
      progressAttribute = gl.getAttribLocation(shader, "progress");
      directionAttribute = gl.getAttribLocation(shader, "variantDirection");
      velocityAttribute = gl.getAttribLocation(shader, "variantVelocity");
      weightAttribute = gl.getAttribLocation(shader, "weight");
      alphaAttribute = gl.getAttribLocation(shader, "alpha");
      gl.enableVertexAttribArray(offsetAttribute);
      gl.enableVertexAttribArray(originIndexAttribute);
      gl.enableVertexAttribArray(progressAttribute);
      gl.enableVertexAttribArray(directionAttribute);
      gl.enableVertexAttribArray(velocityAttribute);
      gl.enableVertexAttribArray(weightAttribute);
      gl.enableVertexAttribArray(alphaAttribute);
      offsetBuffer = gl.createBuffer();
      originIndexBuffer = gl.createBuffer();
      progressBuffer = gl.createBuffer();
      directionBuffer = gl.createBuffer();
      velocityBuffer = gl.createBuffer();
      weightBuffer = gl.createBuffer();
      alphaBuffer = gl.createBuffer();
      buffIt(offsetBuffer, offsetAttribute, offset, 2);
      buffIt(originIndexBuffer, originIndexAttribute, originIndex, 1);
      buffIt(progressBuffer, progressAttribute, progress, 1);
      buffIt(directionBuffer, directionAttribute, direction, 1);
      buffIt(velocityBuffer, velocityAttribute, velocity, 1);
      buffIt(weightBuffer, weightAttribute, weight, 1);
      buffIt(alphaBuffer, alphaAttribute, alpha, 1)
    }
    function setTextures(hexImage, gradientImage, createAndSetupTexture) {
      gl.useProgram(shader);
      var hextureHandle = gl.getUniformLocation(shader, "hexture");
      gradients = createAndSetupTexture(gl, gl.NEAREST, gl.NEAREST);
      gl.bindTexture(gl.TEXTURE_2D, gradients);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, gradientImage);
      hexture = createAndSetupTexture(gl, gl.LINEAR, gl.LINEAR);
      gl.bindTexture(gl.TEXTURE_2D, hexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, hexImage);
      gl.uniform1i(hextureHandle, 1);
      gl.bindTexture(gl.TEXTURE_2D, gradients);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, hexture);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, hexture)
    }
    function setSize(W, H, BW, BH) {
      BASE_W = BW;
      BASE_H = BH;
      if(shader) {
        gl.useProgram(shader);
        gl.uniform2f(resolutionLocation, W, H)
      }
    }
    function setData(parts, centers, maxCenterId) {
      particles = parts;
      particleCount = particles.length;
      centerGroupBuffer = [];
      var c;
      for(var i = 0, L = centers.length; i < L; i++) {
        c = centers[i];
        centerGroupBuffer[c.id] = c.colorGroupId
      }
      centerGroupBuffer = new Float32Array(centerGroupBuffer)
    }
    function drawParticles(mat3, zoom, centerLocationBuffer, centers) {
      frameParticleCount = 0;
      var w;
      for(var i = 0; i < particleCount; i++) {
        particle = particles[i];
        if(particle.complete) {} else {
          if(updatingParticles) {
            particle.update()
          }
          w = particle.origin.density;
          if(w < 1) {
            w = particle.weight
          } else {
            w = particle.weight / w
          }
          offset[frameParticleCount * 2] = particle.offset[0];
          offset[frameParticleCount * 2 + 1] = particle.offset[1];
          originIndex[frameParticleCount] = particle.originId;
          progress[frameParticleCount] = particle.step || 0;
          direction[frameParticleCount] = particle.direction || 0;
          velocity[frameParticleCount] = particle.velocity;
          weight[frameParticleCount] = w * 2;
          alpha[frameParticleCount] = particle.origin.defaultAlpha;
          frameParticleCount++
        }
      }
      gl.useProgram(shader);
      gl.uniform1f(scaleUniform, zoom.value);
      gl.uniformMatrix3fv(matrixUniform, false, mat3);
      gl.uniform4fv(centerLocationUniform, centerLocationBuffer);
      gl.uniform1fv(centerGroupUniform, centerGroupBuffer);
      buffIt(offsetBuffer, offsetAttribute, offset, 2);
      buffIt(originIndexBuffer, originIndexAttribute, originIndex, 1);
      buffIt(progressBuffer, progressAttribute, progress, 1);
      buffIt(directionBuffer, directionAttribute, direction, 1);
      buffIt(velocityBuffer, velocityAttribute, velocity, 1);
      buffIt(weightBuffer, weightAttribute, weight, 1);
      buffIt(alphaBuffer, alphaAttribute, alpha, 1);
      gl.drawArrays(gl.POINTS, 0, frameParticleCount)
    }
    function setUpdating(u) {
      updatingParticles = u
    }
    app.faderShader = {
      init: init,
      shader: null,
      setSize: setSize,
      setData: setData,
      drawParticles: drawParticles,
      setUpdating: setUpdating
    }
  }
  )(app);
  "use strict";
  (function(app) {
    var constants = app.constants, PAUSE = constants.PAUSE, PLAY = constants.PLAY, DRAGGING = constants.DRAGGING, glCanvas, gl, igloo, pathShader, gravitronShader, lerperShader, centers, maxCenterId, W, H, cx, cy, tx, ty, tzoom, baseCx, baseCy, pow = Math.pow, TAU = Math.PI * 2, abs = Math.abs, BASE_ZOOM = 1, BASE_W, BASE_H, lerpParticles, frameParticleCount, hexture, gradients, textureCount = 0, mat3 = [1, 0, 0, 0, 1, 0, 0, 0, 1], zoom, panX, panY, updatingParticles = true, gradientImage, hexImage, centerLocationBuffer = false, faderResolutionLocation, drawingParticles = false, TRAVEL_PIXELS = constants.TRAVEL_PIXELS, browserIsCompatible = false, WIMPY_WEBGL_MESSAGE = "Even though your browser suppports WebGL, it doesn't have what it takes to support this app.", shadersLoaded = false, centersLoaded = false, particlesLoaded = false;
    function setSize(sizes) {
      W = sizes.width;
      H = sizes.height;
      cx = W * 0.5;
      cy = H * 0.5;
      baseCx = cx;
      baseCy = cy;
      if(window.devicePixelRatio > 1) {
        BASE_ZOOM = window.devicePixelRatio;
        BASE_W = W * BASE_ZOOM;
        BASE_H = H * BASE_ZOOM;
        baseCx = cx * BASE_ZOOM;
        baseCy = cy * BASE_ZOOM
      } else {
        BASE_W = W;
        BASE_H = H
      }
      glCanvas.width = BASE_W;
      glCanvas.height = BASE_H;
      if(shadersLoaded) {
        pathShader.setSize(W, H, BASE_W, BASE_H);
        gravitronShader.setSize(W, H, BASE_W, BASE_H);
        lerperShader.setSize(W, H, BASE_W, BASE_H)
      }
    }
    function setCanvas() {
      glCanvas = $("#particles")[0];
      try {
        igloo = new Igloo(glCanvas,{
          premultipliedAlpha: false
        })
      } catch (err) {
        if(!window.WebGLRenderingContext) {
          announceDeferred(constants.GL_STATUS_EVENT, {
            status: constants.GL_UNSUPPORTED,
            message: "Browser does not support WebGL."
          })
        } else {
          announceDeferred(constants.GL_STATUS_EVENT, {
            status: constants.GL_WIMPY,
            message: WIMPY_WEBGL_MESSAGE
          })
        }
        return
      }
      gl = igloo.gl;
      gl.clearColor(1, 1, 1, 1);
      try {
        gl.disable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE)
      } catch (err) {
        console.log("error on blend mode");
        console.log(err)
      }
      initTextures();
      if(checkFramebufferStatus()) {
        browserIsCompatible = true
      } else {
        announceDeferred(constants.GL_STATUS_EVENT, {
          status: constants.GL_WIMPY,
          message: WIMPY_WEBGL_MESSAGE
        })
      }
    }
    function checkFramebufferStatus() {
      var fboStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      switch (fboStatus) {
      case gl.FRAMEBUFFER_COMPLETE:
        return true;
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        console.log("gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT: the attachment types are mismatched.");
        break;
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        console.log("gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: there is no attachment.");
        break;
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        console.log("gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS: the height and width of the attachments are not the same.");
        break;
      case gl.FRAMEBUFFER_UNSUPPORTED:
        console.log("gl.FRAMEBUFFER_UNSUPPORTED: it is what it is.");
        break
      }
      return false
    }
    function initTextures() {
      hexImage = new Image();
      hexImage.onload = function() {
        handleTextureLoaded(hexImage, hexture)
      }
      ;
      hexImage.src = "data/hex.png";
      gradientImage = new Image();
      gradientImage.onload = function() {
        handleTextureLoaded(gradientImage, gradients)
      }
      ;
      gradientImage.src = "data/gradients.png"
    }
    function handleTextureLoaded(image, texture, program) {
      textureCount++;
      if(textureCount >= 2) {
        pathShader = app.pathShader;
        pathShader.init(igloo, gl, buffIt, createAndSetupTexture, gradientImage);
        if(checkFramebufferStatus()) {
          browserIsCompatible = true
        } else {
          announceDeferred(constants.GL_STATUS_EVENT, {
            status: constants.GL_WIMPY,
            message: WIMPY_WEBGL_MESSAGE
          })
        }
        pathShader.setSize(W, H, BASE_W, BASE_H);
        gravitronShader = app.gravitronShader;
        gravitronShader.init(igloo, gl, buffIt);
        gravitronShader.setSize(W, H, BASE_W, BASE_H);
        lerperShader = app.lerperShader;
        lerperShader.init(igloo, gl, buffIt, createAndSetupTexture, hexImage, gradientImage);
        lerperShader.setSize(W, H, BASE_W, BASE_H);
        shadersLoaded = true;
        announceReady()
      }
    }
    function announceReady() {
      if(shadersLoaded && centersLoaded) {
        if(!centerLocationBuffer) {
          centerLocationBuffer = new Float32Array((maxCenterId + 1) * 4);
          gravitronShader.setData(centers, maxCenterId)
        }
        if(particlesLoaded) {
          pathShader.setData(centers, maxCenterId);
          lerperShader.setData(lerpParticles, centers)
        }
        particleGL.announce(constants.GL_STATUS_EVENT, {
          status: constants.READY,
          drawFunction: drawParticles,
          pathUpdateFunction: setPathLengths,
          loadStatus: constants.CENTERS_LOADED
        })
      }
    }
    function setPathLengths() {
      var center, index;
      for(var i = 0; i <= maxCenterId; i++) {
        center = centers[i];
        index = center.id * 4;
        centerLocationBuffer[index] = center.x;
        centerLocationBuffer[index + 1] = center.y;
        centerLocationBuffer[index + 2] = center.groupAngle;
        centerLocationBuffer[index + 3] = center.distance
      }
      pathShader.setLengths(centerLocationBuffer)
    }
    function drawParticles() {
      tzoom = zoom.get() / BASE_ZOOM;
      mat3[0] = tzoom;
      mat3[4] = tzoom;
      mat3[6] = panX.get() / W * 2 / BASE_ZOOM;
      mat3[7] = -panY.get() / H * 2 / BASE_ZOOM;
      gl.useProgram(gravitronShader.shader);
      gl.viewport(0, 0, BASE_W, BASE_H);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gravitronShader.drawNodes(mat3, zoom);
      lerperShader.drawParticles(mat3, zoom, centerLocationBuffer)
    }
    function buffIt(buffer, attribute, src, size) {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.vertexAttribPointer(attribute, size, gl.FLOAT, false, 0, 0);
      gl.bufferData(gl.ARRAY_BUFFER, src, gl.DYNAMIC_DRAW)
    }
    function setData(data) {
      centers = data.centers;
      maxCenterId = -1;
      for(var i = centers.length - 1; i >= 0; i--) {
        if(centers[i].id > maxCenterId) {
          maxCenterId = centers[i].id
        }
      }
      centersLoaded = true;
      announceReady()
    }
    function setParticleData(data) {
      lerpParticles = data.lerpers;
      particlesLoaded = true;
      announceReady()
    }
    function setUpdater(params) {
      if(browserIsCompatible) {
        drawingParticles = !!params.drawParticles
      }
    }
    function createAndSetupTexture(gl, TEXTURE_MIN_FILTER, TEXTURE_MAG_FILTER) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, TEXTURE_MIN_FILTER);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, TEXTURE_MAG_FILTER);
      return texture
    }
    function announceDeferred(event, params) {
      setTimeout(function() {
        particleGL.announce(event, params)
      }, 300)
    }
    function setZoomerPanner(data) {
      zoom = data.zoom;
      panX = data.panX;
      panY = data.panY
    }
    function setPlayback(action) {
      if(action == PAUSE) {
        updatingParticles = false;
        app.lerperShader.setUpdating(false)
      } else {
        if(action == PLAY) {
          updatingParticles = true;
          app.lerperShader.setUpdating(true)
        }
      }
    }
    var particleGL = {
      setCanvas: setCanvas,
      setData: setData,
      setSize: setSize,
      setUpdater: setUpdater,
      setZoomerPanner: setZoomerPanner,
      setPlayback: setPlayback,
      setParticleData: setParticleData
    };
    setCanvas();
    F.eventify(particleGL);
    app.particleGL = particleGL
  }
  )(window.app);
  "use strict";
  (function(app) {
    var constants = app.constants, SoftFloat = F.SoftFloat, cos = Math.cos, sin = Math.sin, round = Math.round, HALF_PI = Math.PI * 0.5, QTR_PI = Math.PI * 0.25, TAU = Math.PI * 2, LIGHT = 0.3, DARK = 0.9, NODE_SIZE = constants.INTRO_NODE_SIZE, HIGHLIGHT_ALPHA_MOD = 8, stepTime, HOVER = constants.HOVER, CLEAR = constants.CLEAR, GROUP = constants.GROUP, SELECT_EVENT = constants.SELECT_EVENT, RING_MARGIN_MIN = constants.RING_MARGIN_MIN, RING_MARGIN_COEFFICIENT = constants.RING_MARGIN_COEFFICIENT, FADE_WAIT = 500, READ_WAIT = 1500, shadersLoaded = false, dataLoaded = false, domReady = false, centerRadius = new F.SoftFloat(0.001), $progressBar = $("#overview-progress"), launched = false;
    var step = 0, groups, driver, ring, latestGroup = 0, complete = false, items = [], waitEndTime;
    function IntroItem(group, angle) {
      this.group = group;
      this.label = group.name;
      this.cosA = cos(angle);
      this.sinA = sin(angle);
      this.x = group.x;
      this.y = group.y;
      this.$label = $("#intro-" + group.name.toLowerCase())
    }
    IntroItem.prototype.updatePosition = function(r) {
      this.x = this.group.x + this.cosA * r;
      this.y = this.group.y + this.sinA * r
    }
    ;
    IntroItem.prototype.highlight = function() {
      var centers = this.group.centers, grav;
      for(var i = 0, L = centers.length; i < L; i++) {
        grav = centers[i];
        grav.size.setTarget(NODE_SIZE);
        grav.layoutSize.setTarget(NODE_SIZE);
        grav.alpha.setTarget(1)
      }
      this.$label.removeClass("hidden");
      this.$label.addClass("primary")
    }
    ;
    IntroItem.prototype.pushBack = function() {
      this.$label.removeClass("primary");
      var centers = this.group.centers, grav;
      for(var i = 0, L = centers.length; i < L; i++) {
        grav = centers[i];
        grav.alpha.setTarget(0.2)
      }
    }
    ;
    IntroItem.prototype.drawLabel = function() {
      this.$label.css("left", this.x);
      this.$label.css("top", this.y)
    }
    ;
    function launch() {
      if(shadersLoaded && dataLoaded && domReady && !launched) {
        launched = true;
        intro.announce(constants.LEGEND_SPEED_EVENT, {
          attraction: 0.2,
          damping: 0.15
        });
        intro.announce(constants.LOOPER_CONTROL_EVENT, {
          updater: update,
          extraDrawer: drawLabels,
          nodeFunction: updateGroups
        });
        centerRadius.setTarget(constants.INTRO_RING_MARGIN_MIN);
        stepTime = Date.now()
      }
    }
    function setData(data) {
      groups = data.groups;
      driver = groups[0];
      ring = data.ring;
      items[0] = new IntroItem(groups[0],-HALF_PI);
      items[1] = new IntroItem(groups[1],-HALF_PI);
      items[2] = new IntroItem(groups[2],QTR_PI);
      items[3] = new IntroItem(groups[3],QTR_PI * 3);
      setRingPositions();
      dataLoaded = true;
      launch()
    }
    function setRingPositions() {
      var innerMostR = driver.arcs[0].radius;
      if(undefined == innerMostR) {
        return
      }
      var middleR = driver.radius;
      var outerMostR = ring.radius;
      var innerR = innerMostR + (middleR - innerMostR) * 0.5;
      var outerSpan = (outerMostR - middleR);
      var midOuter = middleR + outerSpan * 0.5;
      var midOuterLower = middleR + outerSpan * 0.4;
      items[0].updatePosition(innerR * 1.6);
      items[1].updatePosition(midOuter * 1.55);
      items[2].updatePosition(midOuterLower * 1.5);
      items[3].updatePosition(midOuterLower * 1.5)
    }
    function updateGravitron(grav) {
      grav.updateValues()
    }
    function updateGroups() {
      for(var i = 0; i <= latestGroup; i++) {
        groups[i].centers.forEach(updateGravitron)
      }
    }
    function update() {
      if(complete) {
        return
      }
      driver.update();
      ring.update(driver.getPathRadius() * RING_MARGIN_COEFFICIENT + constants.RING_MARGIN_MIN);
      setRingPositions();
      var now = Date.now();
      var startStep = step;
      switch (step) {
      case 0:
        highlightGroup(0);
        waitEndTime = now + READ_WAIT;
        intro.announce(constants.ZOOM_PAN_EVENT, {
          zoom: 1.5
        });
        step++;
        break;
      case 1:
        if(waitEndTime <= now) {
          waitEndTime = now + FADE_WAIT;
          fadePreceding(1);
          step++
        }
        break;
      case 2:
        if(waitEndTime <= now) {
          waitEndTime = now + READ_WAIT;
          highlightGroup(1);
          step++
        }
        break;
      case 3:
        if(now >= waitEndTime) {
          waitEndTime = now + FADE_WAIT;
          fadePreceding(2);
          step++
        }
        break;
      case 4:
        if(now >= waitEndTime) {
          waitEndTime = now + READ_WAIT;
          highlightGroup(2);
          step++
        }
        break;
      case 5:
        if(now >= waitEndTime) {
          waitEndTime = now + FADE_WAIT;
          fadePreceding(3);
          step++
        }
        break;
      case 6:
        if(now >= waitEndTime) {
          waitEndTime = now + READ_WAIT;
          highlightGroup(3);
          step++
        }
        break;
      case 7:
        if(now >= waitEndTime) {
          waitEndTime = now + FADE_WAIT;
          fadePreceding(4);
          step++
        }
        break;
      case 8:
        if(now >= waitEndTime) {
          tidyUp()
        }
        break;
      default:
        tidyUp();
        break
      }
      if(startStep != step) {
        var prog = Math.round((step + 1) / 8 * 100);
        if(prog > 100) {
          prog = 100
        }
        $progressBar.css("width", prog + "%")
      }
    }
    function drawLabels() {
      for(var i = 0, L = items.length; i < L; i++) {
        items[i].drawLabel()
      }
    }
    function fadePreceding(index) {
      for(var i = 0; i < index; i++) {
        items[i].pushBack()
      }
      intro.announce(constants.SELECT_EVENT, {
        type: GROUP,
        action: HOVER,
        item: false
      })
    }
    function highlightGroup(index) {
      var centers = items[index].group.centers;
      for(var i = 0, L = centers.length; i < L; i++) {
        centers[i].movingCount = centers[i].colorGroupId ? 500 : 250;
        centers[i].layoutSize.set(i * -10 / L)
      }
      items[index].highlight();
      latestGroup = index;
      intro.announce(constants.SELECT_EVENT, {
        type: GROUP,
        action: HOVER,
        item: groups[index]
      })
    }
    function tidyUp() {
      items.forEach(function(item) {
        var centers = item.group.centers;
        for(var i = 0, L = centers.length; i < L; i++) {
          centers[i].movingCount = 0
        }
      });
      intro.announce(constants.ZOOM_PAN_EVENT, {
        zoom: constants.DEFAULT_ZOOM
      });
      complete = true;
      $(".intro-label").addClass("hidden");
      $("#skip-overview").removeClass("enabled");
      intro.announce(constants.SELECT_EVENT, {
        type: CLEAR,
        action: HOVER
      });
      intro.announce(constants.LEGEND_SPEED_EVENT, {
        attraction: 0.2,
        damping: 0.5
      });
      intro.announce(constants.INTRO_COMPLETE_EVENT);
      setTimeout(function() {
        $(".intro-label").remove();
        $("#skip-overview").remove()
      }, 1000)
    }
    function showSkipOption() {
      $("#skip-overview").addClass("enabled");
      $("#skip-button").bind("click", function() {
        tidyUp()
      })
    }
    function setGLReady(params) {
      if(params.status == constants.READY) {
        shadersLoaded = true;
        launch()
      }
    }
    function setDomReady() {
      domReady = true;
      launch()
    }
    var intro = {
      setData: setData,
      setShaderReady: setGLReady,
      showSkipOption: showSkipOption,
      setDomReady: setDomReady
    };
    F.eventify(intro);
    app.intro = intro
  }
  )(window.app);
  "use strict";
  (function(app) {
    var constants = app.constants, centers, centerLookup, groups, driver, ring, bursts, second, priorSecond, random = Math.random, pow = Math.pow, sin = Math.sin, cos = Math.cos, TAU = Math.PI * 2, PARTICLE_VELOCITY_ROOT = constants.PARTICLE_VELOCITY_ROOT, PARTICLE_VELOCITY_RANGE = constants.PARTICLE_VELOCITY_RANGE, PARTICLE_OFFSET_RANGE = constants.PARTICLE_OFFSET_RANGE, EVENT_MIN_SIZE = constants.EVENT_MIN_SIZE, LOOPER_CONTROL_EVENT = constants.LOOPER_CONTROL_EVENT, RING_MARGIN_MIN = constants.RING_MARGIN_MIN, RING_MARGIN_COEFFICIENT = constants.RING_MARGIN_COEFFICIENT, TIME_UPDATE_EVENT = constants.TIME_UPDATE_EVENT, SECONDS_PER_FRAME = 5, AFTER = constants.AFTER, PAUSE = constants.PAUSE, PLAY = constants.PLAY, DRAGGING = constants.DRAGGING, paused = false, dragging = false, HOVER = constants.HOVER, LOCK = constants.LOCK, CLEAR = constants.CLEAR, GROUP = constants.GROUP, GRAVITRON = constants.GRAVITRON, SELECT_EVENT = constants.SELECT_EVENT, mousedItem = false, lockedItem = false, introComplete = false, dataReady = false, shaderReady = false, particlesAnnounced = false;
    (function() {
      var d = new Date();
      second = d.getSeconds() + 60 * d.getMinutes() + 3600 * d.getHours();
      second = 3600 * 9;
      priorSecond = second - 1
    }
    )();
    function ParticleRecycler(generator, limit) {
      this.particles = [];
      this.count = 0;
      this.index = 0;
      this.hasAvailable = true;
      this.getNewParticle = generator;
      this.LIMIT = limit;
      for(var i = 0; i < limit; i++) {
        this.addParticle()
      }
    }
    ParticleRecycler.prototype.size = function() {
      return this.particles.length
    }
    ;
    ParticleRecycler.prototype.setDirty = function() {
      this.hasAvailable = true
    }
    ;
    ParticleRecycler.prototype.getParticle = function() {
      var p = null;
      if(this.hasAvailable) {
        var index = this.index
        , count = this.count
        , particles = this.particles
        , startIndex = index;
        while (index < count) {
          if(particles[index].isComplete()) {
            p = particles[index];
            index++;
            break
          }
          index++
        }
        if(null == p) {
          index = 0;
          while (index < startIndex) {
            if(particles[index].isComplete()) {
              p = particles[index];
              index++;
              break
            }
            index++
          }
        }
        this.index = index;
        if(null == p) {
          this.hasAvailable = false
        }
      }
      return p
    }
    ;
    ParticleRecycler.prototype.addParticle = function() {
      var p = this.getNewParticle();
      this.particles.push(p);
      this.count++;
      return p
    }
    ;
    function getNewLerperParticle() {
      var r = random() * PARTICLE_OFFSET_RANGE;
      var a = random() * TAU;
      var offset = [cos(a) * r, sin(a) * r];
      return new app.Lerper(offset,PARTICLE_VELOCITY_ROOT + random() * PARTICLE_VELOCITY_RANGE)
    }
    var lerpers = new ParticleRecycler(getNewLerperParticle,constants.MAX_LERPER_COUNT);
    function launch() {
      if(dataReady && shaderReady) {
        if(introComplete) {
          groups.forEach(unhighlightGroup);
          particles.announce(LOOPER_CONTROL_EVENT, {
            updater: update,
            drawParticles: true
          })
        } else {
          if(!particlesAnnounced) {
            particlesAnnounced = true;
            particles.announce(constants.PARTICLES_READY_EVENT)
          }
        }
      }
    }
    function updateGroupPaths(g) {
      g.updatePaths()
    }
    function updatePathFunction() {
      groups.forEach(updateGroupPaths)
    }
    function update() {
      if(paused) {
        return
      }
      if(dragging) {}
      lerpers.setDirty();
      driver.update();
      ring.update(driver.radius * RING_MARGIN_COEFFICIENT + RING_MARGIN_MIN);
      updatePathFunction();
      for(var p = priorSecond + 1; p <= second; p++) {
        releaseParticles(p)
      }
      particles.announce(TIME_UPDATE_EVENT, second);
      priorSecond = second;
      if(!paused && !dragging) {
        second = (second + SECONDS_PER_FRAME) % AFTER
      }
    }
    function setData(data) {
      centers = data.centers;
      centerLookup = data.centerLookup;
      groups = data.groups;
      driver = groups[0];
      ring = data.ring;
      bursts = data.bursts;
      dataReady = true;
      particles.announce(constants.DATA_LOAD_EVENT, {
        lerpers: lerpers.particles
      });
      launch()
    }
    function setSecond(s) {
      second = s;
      priorSecond = s - 1
    }
    function setPlayback(action) {
      if(action == PAUSE) {
        paused = true;
        dragging = false
      } else {
        if(action == DRAGGING) {
          dragging = true
        } else {
          if(action == PLAY) {
            paused = false;
            dragging = false
          }
        }
      }
    }
    function releaseParticles(s) {
      var secondBursts = bursts[s], b, origin, destination, count, p, recycler, addFunction;
      if(!secondBursts) {
        return
      }
      for(var i = 0, L = secondBursts.length; i < L; i++) {
        b = secondBursts[i];
        origin = centerLookup[b.origin];
        destination = centerLookup[b.destination];
        count = b.count;
        if(destination && b.destination != b.origin) {
          recycler = lerpers;
          for(var j = 0, jL = count; j < jL; j++) {
            p = recycler.getParticle();
            try {
              p.set(origin, destination)
            } catch (err) {
              break
            }
          }
        }
      }
    }
    function setSelectedGroup(group) {
      if(group) {
        groups.forEach(pushBackGroup);
        group.highlight()
      } else {
        groups.forEach(unhighlightGroup)
      }
      particles.announce(SELECT_EVENT, {
        type: GROUP,
        action: HOVER,
        item: group
      })
    }
    function unhighlightGroup(group) {
      group.unhighlight()
    }
    function pushBackGroup(group) {
      group.pushBack()
    }
    function unhighlightNode(node) {
      node.unhighlight();
      node.unhighlightLabel()
    }
    function pushBackNode(node) {
      node.pushBack()
    }
    function handleSelect(params) {
      if(params.action == LOCK) {
        var zoomGroup = false;
        if(params.type == CLEAR || !params.item || params.item == lockedItem.item) {
          if(lockedItem) {
            $(".label-node").css("opacity", 0);
            if(lockedItem.type == GRAVITRON || lockedItem.type == GROUP) {
              lockedItem.item.unhighlight()
            }
          }
          lockedItem = false;
          params.type = CLEAR;
          params.item = false
        } else {
          if(params.type == GROUP) {
            zoomGroup = params.item;
            lockedItem = params
          } else {
            if(params.type == GRAVITRON) {
              if(lockedItem) {
                if(lockedItem.type == GROUP) {} else {
                  if(lockedItem.type == GRAVITRON) {
                    lockedItem.item.unhighlight();
                    for(var i = centers.length - 1; i >= 0; i--) {
                      centers[i].unhighlightLabel()
                    }
                  }
                }
              }
              zoomGroup = params.item.parent;
              lockedItem = params
            }
          }
        }
        particles.announce(SELECT_EVENT, params);
        if(zoomGroup) {
          var rect = zoomGroup.getBounds();
          particles.announce(constants.BOX_FOCUS_EVENT, rect)
        } else {
          particles.announce(constants.BOX_FOCUS_EVENT, false)
        }
      } else {
        if(params.action == HOVER) {
          if(mousedItem && mousedItem.item !== params.item && mousedItem != lockedItem) {
            if(lockedItem || (params.type !== CLEAR && params.item)) {
              mousedItem.item.pushBack()
            } else {
              mousedItem.item.unhighlight()
            }
          }
          if(params.type == CLEAR || !params.item) {
            if(lockedItem) {
              groups.forEach(pushBackGroup);
              lockedItem.item.highlight()
            } else {
              groups.forEach(unhighlightGroup)
            }
            mousedItem = false;
            if(lockedItem) {
              params.type = lockedItem.type;
              params.item = lockedItem.item
            } else {
              params.type = CLEAR;
              params.item = false
            }
          } else {
            if(params.type == GROUP) {
              mousedItem = params;
              groups.forEach(pushBackGroup);
              params.item.highlight()
            } else {
              if(params.type == GRAVITRON) {
                mousedItem = params;
                centers.forEach(pushBackNode);
                params.item.highlight()
              }
            }
          }
          particles.announce(SELECT_EVENT, params)
        }
      }
    }
    function setPathUpdateFunction(data) {
      if(data.status == constants.READY) {
        shaderReady = true;
        updatePathFunction = function() {
          groups.forEach(updateGroupPaths);
          data.pathUpdateFunction()
        }
        ;
        launch()
      }
    }
    function handleIntroComplete() {
      introComplete = true;
      launch()
    }
    function handleZoomReset() {
      handleSelect({
        type: CLEAR,
        action: LOCK,
        item: false
      });
      handleSelect({
        type: CLEAR,
        action: HOVER,
        item: false
      })
    }
    var particles = {
      handleIntroComplete: handleIntroComplete,
      setData: setData,
      setSecond: setSecond,
      setPlayback: setPlayback,
      handleSelect: handleSelect,
      setPathUpdateFunction: setPathUpdateFunction,
      handleZoomReset: handleZoomReset
    };
    F.eventify(particles);
    app.particles = particles
  }
  )(window.app);
  "use strict";
  (function(app) {
    var constants = app.constants
    , HOVER = constants.HOVER
    , LOCK = constants.LOCK
    , CLEAR = constants.CLEAR
    , GROUP = constants.GROUP
    , GRAVITRON = constants.GRAVITRON;
    function setSize() {
      var w = $(window).width()
      , h = $(window).height()
      , headerHeight = $("#header").height();
      dom.announce(constants.RESIZE_EVENT, {
        width: w,
        height: h,
        headerHeight: headerHeight
      });
      return [w, h]
    }
    function init() {
      var $nodeLabelTemplate = $(".node-label")
      , $labelParent = $nodeLabelTemplate.parent();
      $nodeLabelTemplate.remove();
      dom.announce(constants.DOM_READY_EVENT, {
        $nodeLabelTemplate: $nodeLabelTemplate,
        $labelParent: $labelParent
      });
      var dims = setSize();
      checkMobile(dims)
    }
    function checkMobile(dims) {
      if(F.env.isTouch || dims[0] < 400 || dims[1] < 400) {
        window.location = "./video.html"
      }
    }
    function activateControls() {
      $("#timeline").removeClass("inactive");
      $("#zoom-controls").removeClass("inactive");
      $(document).bind("mousedown", function(e) {
        dom.announce(constants.SELECT_EVENT, {
          action: LOCK,
          item: false,
          type: CLEAR
        })
      });
      $(document).bind("mousemove", function() {
        dom.announce(constants.SELECT_EVENT, {
          action: HOVER,
          item: false,
          type: CLEAR
        })
      })
    }
    function setWebGLNotOK(data) {
      if(data.status !== constants.READY) {
        $("#main").empty();
        $("#timeline").remove();
        $("#legend").remove();
        $("#loader-text").remove();
        $("#blizzard").addClass("active")
      } else {
        $("#blizzard").remove()
      }
    }
    function endIntro() {
      $("body").removeClass("intro");
      setTimeout(function() {
        $("#loader-text").remove()
      }, 500)
    }
    function endLoad() {
      requestAnimationFrame(function() {
        $("body").addClass("intro");
        $("body").removeClass("loading");
        dom.announce(constants.APP_LAUNCH_EVENT)
      })
    }
    function handleSelect(params) {
      if(params.action == LOCK) {
        if(params.type == CLEAR) {
          $("body").removeClass("zoomed")
        } else {
          $("body").addClass("zoomed")
        }
      }
    }
    setTimeout(endLoad, 400);
    $(window).bind("resize", setSize);
    var dom = {
      init: init,
      activateControls: activateControls,
      setWebGLNotOK: setWebGLNotOK,
      endIntro: endIntro,
      handleSelect: handleSelect
    };
    F.eventify(dom);
    app.dom = dom
  }
  )(window.app);
  "use strict";
  (function(app) {
    var constants = app.constants, centers, centerLookup, groups, ring, $labelTemplate, $labelParent, AFTER = constants.AFTER, EVENT_DESRIPTIONS = {
      0: "Patient begins the check-in process.",
      1: "Completed patient check-in.",
      2: "The intake process begins with an athenahealth practice.",
      3: "Mid-level completes patient intake.",
      4: "Patient exam begins.",
      5: "Patient leaves exam room.",
      6: "Provider completes all necessary documentation, including placing of orders.",
      7: "Patient chart closed after completion of required documentation and orders.",
      8: "Patient begins the checkout process.",
      9: "Patient completes checkout.",
      10: "Patient email address collected at check-in.",
      11: "Patient phone number collected at check-in.",
      12: "Patient license information collected at check-in.",
      13: "Patient viewed a message in their portal inbox.",
      14: "Required documentation following the visit is started.",
      15: "Required documentation for patient visit completed.",
      16: "The order for a lab, imaging, surgical or other procedure is tied back to the chart.",
      17: "The results of a consultation or procedure is reviewed by the provider.",
      18: "Provider discusses prescription, consultation, or procedure with patient..",
      19: "Procedure or surgery ordered by provider.",
      20: "Request sent to pharmacy for prescription renewal or refill.",
      21: "Claim created for submission to payers.",
      22: "Patient screened for insurance eligibility.",
      23: "Claim sent to the payer for payment.",
      24: "Charges for visits or procedures billed to patient.",
      25: "Patients payment-responsibility transferred.",
      26: "Charges not covered by the primary payer are transferred to a secondary payer.",
      27: "Practice receives claim adjudication details from payer.",
      28: "Funds transferred from the payer to the practice.",
      29: "Patients payment received by practice.",
      30: "Claim closed following fulfillment of payment.",
      31: "Patient logs in to portal.",
      32: "Patient viewed their health history.",
      33: "Patient viewed results.",
      34: "Patient viewed current or previous medications.",
      35: "Prescription coupons viewed by patient via the portal.",
      36: "Patient viewed vitals via the portal.",
      37: "Patient viewed care summaries online.",
      38: "Patient viewed their charges for care.",
      39: "Patient makes a payment on the portal.",
      40: "Patient schedules appointment via the portal.",
      41: "Patient sends request for appointment, prescription refill or medical question.",
      42: "Patient modifies settings on their portal account.",
      43: "Patient updates account information on portal.",
      44: "Message sent from patient to provider.",
      45: "Patient finishes a session on the portal.",
      46: "Imaging procedures ordered.",
      47: "Prescriptions submitted by provider.",
      48: "Order submitted for consult.",
      49: "Patient sees another provider/specialist as referred by the practice.",
      50: "Ordered imaging procedure is performed.",
      51: "Ordered lab procedure is performed.",
      52: "Order submitted for lab procedure.",
      53: "Rejected or denied claims corrected by our service teams for resubmission.",
      54: "Error automatically flagged for correction by our billing rules engine before submission to payer.",
      55: "Claim flagged with errors by the payer is moved to the appropriate workflow for correction.",
      56: "Claim adjusted by payers to reflect differences in billing and payment.",
      57: "Claim returned to athena for correction.",
      58: "Payer receives bill for services rendered in the form of an itemized claim.",
      59: "Patient determined ineligible for coverage by payers.",
      60: "Patient ruled eligible for coverage by payers.",
      61: "Payer sends confirmation that a claim was received."
    }, GROUP_DATA = {
      Practice: [{
        subtype: "Practice Encounter",
        name: "Check-in end",
        id: 1
      }, {
        subtype: "Practice Encounter",
        name: "Intake start",
        id: 2
      }, {
        subtype: "Practice Encounter",
        name: "Exam end",
        id: 5
      }, {
        subtype: "Practice Encounter",
        name: "Signoff start",
        id: 6
      }, {
        subtype: "Practice Encounter",
        name: "Checkout end",
        id: 9
      }, {
        subtype: "Practice Encounter",
        name: "Checkout start",
        id: 8
      }, {
        subtype: "Practice Encounter",
        name: "Signoff end",
        id: 7
      }, {
        subtype: "Practice Encounter",
        name: "Exam start",
        id: 4
      }, {
        subtype: "Practice Encounter",
        name: "Intake end",
        id: 3
      }, {
        subtype: "Practice Encounter",
        name: "Check-in start",
        id: 0
      }, {
        subtype: "Practice to Patient",
        name: "Patient email collected",
        id: 10
      }, {
        subtype: "Practice to Patient",
        name: "Patient phone number collected",
        id: 11
      }, {
        subtype: "Practice to Patient",
        name: "Patient license collected",
        id: 12
      }, {
        subtype: "Practice to Patient",
        name: "Sent message to patient",
        id: 13
      }, {
        subtype: "Practice to Orders",
        name: "Result tied back to order",
        id: 16
      }, {
        subtype: "Practice to Orders",
        name: "Result reviewed by provider",
        id: 17
      }, {
        subtype: "Practice to Orders",
        name: "Result discussed with patient",
        id: 18
      }, {
        subtype: "Practice to Orders",
        name: "Procedure/surgery order created",
        id: 19
      }, {
        subtype: "Practice to Orders",
        name: "Prescription renewal request received",
        id: 20
      }, {
        subtype: "Practice to Orders",
        name: "Post-visit documentation start",
        id: 14
      }, {
        subtype: "Practice to Orders",
        name: "Post-visit documentation end",
        id: 15
      }, {
        subtype: "Practice to Payer",
        name: "Claim created",
        id: 21
      }, {
        subtype: "Practice to Payer",
        name: "Eligibility check start",
        id: 22
      }, {
        subtype: "Practice to Payer",
        name: "Bill event",
        id: 23
      }, {
        subtype: "Practice to Payer",
        name: "Charge to patient",
        id: 24
      }, {
        subtype: "Practice to Payer",
        name: "Balance transfer to patient",
        id: 25
      }, {
        subtype: "Practice to Payer",
        name: "Balance transfer to secondary payer",
        id: 26
      }, {
        subtype: "Practice to Payer",
        name: "Supporting payment details from payer",
        id: 27
      }, {
        subtype: "Practice to Payer",
        name: "Payment by payer",
        id: 28
      }, {
        subtype: "Practice to Payer",
        name: "Payment by patient",
        id: 29
      }, {
        subtype: "Practice to Payer",
        name: "Claim closed",
        id: 30
      }],
      Patient: [{
        name: "Patient login",
        id: 31
      }, {
        name: "Viewed health history",
        id: 32
      }, {
        name: "Viewed lab results",
        id: 33
      }, {
        name: "Viewed medications",
        id: 34
      }, {
        name: "Viewed prescription coupon",
        id: 35
      }, {
        name: "Viewed vitals",
        id: 36
      }, {
        name: "Viewed care summary",
        id: 37
      }, {
        name: "Viewed charges",
        id: 38
      }, {
        name: "Paid charges",
        id: 39
      }, {
        name: "Appointment scheduled via portal",
        id: 40
      }, {
        name: "Request submitted",
        id: 41
      }, {
        name: "Managed portal account",
        id: 42
      }, {
        name: "Updated patient info",
        id: 43
      }, {
        name: "Sent message",
        id: 44
      }, {
        name: "Patient logout",
        id: 45
      }],
      Orders: [{
        name: "Imaging order submitted",
        id: 46
      }, {
        name: "Prescription submitted",
        id: 47
      }, {
        name: "Consult order submitted",
        id: 48
      }, {
        name: "Consult order performed",
        id: 49
      }, {
        name: "Imaging order performed",
        id: 50
      }, {
        name: "Lab order performed",
        id: 51
      }, {
        name: "Lab order submitted",
        id: 52
      }],
      Payer: [{
        name: "athenahealth scrub",
        id: 53
      }, {
        name: "Claim rule fired",
        id: 54
      }, {
        name: "Kick reason fired",
        id: 55
      }, {
        name: "Payer adjustment",
        id: 56
      }, {
        name: "Claim returned",
        id: 57
      }, {
        name: "Charge to payer",
        id: 58
      }, {
        name: "Patient is ineligible",
        id: 59
      }, {
        name: "Patient is eligible",
        id: 60
      }, {
        name: "Payer acknowledgement",
        id: 61
      }]
    }, BEZIER_CONTROLS = {
      "0": {
        "1": [0.6347, 0.705, -2.395, 0.8302]
      },
      "1": {
        "2": [0.6851, 0.7347, 3.8261, 0.6963],
        "8": [0.7431, 0.5115, 3.882, 0.487]
      },
      "2": {
        "3": [-5.4829, 0.5022, -2.5171, 0.4917]
      },
      "3": {
        "4": [-0.7087, 0.7966, 2.4155, 1.0541]
      },
      "4": {
        "5": [-0.4394, 0.5456, 2.6615, 0.5475]
      },
      "5": {
        "0": [-0.4929, 0.3881, -3.8244, 0.6209],
        "4": [5.9059, 0.4102, 2.8157, 0.4203],
        "6": [1.0586, 1.0448, 4.1108, 0.7858]
      },
      "6": {
        "7": [5.832, 0.749, 2.7775, 0.6664]
      },
      "7": {
        "0": [-0.7423, 0.8156, -3.736, 0.5203],
        "8": [0.791, 0.7252, -2.2372, 0.5809]
      },
      "8": {
        "0": [-0.8191, 0.4318, -4.0206, 0.3532],
        "9": [-0.5196, 0.8028, 2.4644, 0.6429]
      },
      "9": {
        "8": [5.3853, 0.737, 2.1727, 0.8408]
      }
    };
    function load() {
      centers = [];
      groups = [];
      centerLookup = {};
      var lerpColors = initLerpColors();
      var groupLookup = {}
      , groupCount = 0;
      var GROUP_NAMES = constants.GROUP_NAMES;
      var arcs = [];
      var groupDescriptionDict = {};
      $(".intro-label").each(function(i, o) {
        var name = $(this).find(".intro-title").text()
        , descriptionContainer = $(this).find(".intro-text")
        , description = descriptionContainer.text();
        groupDescriptionDict[name] = description;
        descriptionContainer.remove()
      });
      for(var n = 0, Ln = GROUP_NAMES.length; n < Ln; n++) {
        var groupName = GROUP_NAMES[n];
        var group;
        var description = groupDescriptionDict[groupName];
        if(groupName == "Practice") {
          group = new app.SuperGroup(groupCount,groupName,constants.GROUP_COLORS[n],lerpColors[n],groupDescriptionDict)
        } else {
          group = new app.ArcGroup(groupCount,groupName,constants.GROUP_COLORS[n],lerpColors[n],groupDescriptionDict);
          arcs.push(group)
        }
        groupLookup[groupName] = group;
        groups.push(group);
        groupCount++;
        var nodes = GROUP_DATA[groupName];
        for(var i = 0, L = nodes.length; i < L; i++) {
          var node = nodes[i]
          , minSize = constants.PRACTICE_EVENT_MIN_SIZE
          , layoutMinSize = constants.PRACTICE_EVENT_MIN_SIZE
          , sizeRange = constants.PRACTICE_EVENT_SIZE_RANGE
          , layoutSizeRange = constants.EVENT_LAYOUT_SIZE_RANGE
          , colorId = group.groupId;
          if("Practice" == groupName) {
            if("Practice Encounter" == node.subtype) {
              minSize = constants.PRACTICE_EVENT_MIN_SIZE;
              layoutMinSize = constants.PRACTICE_EVENT_MIN_SIZE;
              sizeRange = constants.PRACTICE_EVENT_SIZE_RANGE;
              layoutSizeRange = constants.PRACTICE_EVENT_LAYOUT_SIZE_RANGE
            } else {
              colorId = 4
            }
          }
          var $label = $labelTemplate.clone();
          var description = EVENT_DESRIPTIONS[node.id];
          var sizes = {
            minSize: minSize,
            layoutMinSize: layoutMinSize,
            sizeRange: sizeRange,
            layoutSizeRange: layoutSizeRange
          };
          $label.text(node.name);
          $labelParent.append($label);
          var center = new app.Gravitron(node.id,node.name,node.subtype,group,colorId,sizes,$label,description);
          group.addNode(center);
          centers.push(center);
          centerLookup[center.id] = center
        }
      }
      ring = new app.RingGroup(arcs);
      dataLoader.announce(constants.NODES_INITIALIZED_EVENT, {
        ring        : ring,
        groups      : groups,
        centers     : centers,
        centerLookup: centerLookup,
      });
      loadEvents(source)
    }
    function loadEvents(data) {
      if("string" == typeof data) data = JSON.parse(data)
      var burstData, burstList, secondsPerInterval = constants.SECONDS_PER_HISTOGRAM_BUCKET, intervalIndex, floor = Math.floor;
      var origin, originId, group, subGroup;
      var bursts = _.times(AFTER, i => [])
      var binnedCounts = _.times(constants.HISTOGRAM_INTERVAL_COUNT, 0);
      var secondCounts = _.times(AFTER, i => 0);
      
      _.each(groups, (n, i) => {
        group = n
        subGroup = groups[0].arcs[i]
        group.secondCounts    = _.times(AFTER, i => 0)
        subGroup.secondCounts = _.times(AFTER, i => 0)
      })
      
      var origins = [];
      var destinations = [];
      var requiredPaths = [];
      var batchCount = 0;
      for(var originId in data) {
        originId = parseInt(originId);
        origins.push(originId);
        requiredPaths[originId] = []
      }
      function finalizeNode(origin) {
        if(!origin) {
          return
        }
        origin.binMax = Math.max.apply(null, origin.binnedCounts);
        var seconds = origin.secondCounts
        , cumulatives = origin.cumulativeCounts;
        cumulatives[0] = seconds[0];
        for(var i = 1, L = seconds.length; i < L; i++) {
          cumulatives[i] = cumulatives[i - 1] + seconds[i]
        }
        delete origin.secondCounts
      }
      function handleBatch() {
        var end = Date.now() + 5;
        batchCount++;
        if(destinations.length == 0) {
          if(origins.length == 0) {
            finalizeNode(origin);
            setTimeout(finalize, 50);
            return
          } else {
            finalizeNode(origin);
            originId = origins.shift();
            origin = centerLookup[originId];
            group = groups[origin.groupId];
            burstData = data[originId];
            destinations = [];
            for(var destinationId in burstData) {
              destinationId = parseInt(destinationId);
              if(originId != destinationId) {
                destinations.push(destinationId);
                requiredPaths[originId][destinationId] = true
              }
            }
            origin.secondCounts = [];
            for(var i = 0; i < AFTER; i++) {
              origin.secondCounts[i] = 0
            }
          }
        }
        while (Date.now() < end && destinations.length > 0) {
          var destinationId = destinations.shift();
          burstList = burstData[destinationId];
          for(var i = 0, L = burstList.length; i < L; i++) {
            var bd = burstList[i]
            , second = bd[0]
            , count = bd[1]
            , burstSecond = bursts[second];
            if(second >= 0 && second < AFTER) {
              burstSecond.push({
                origin: originId,
                destination: destinationId,
                count: count
              });
              secondCounts[second] += count;
              origin.secondCounts[second] += count;
              group.secondCounts[second] += count;
              intervalIndex = floor(second / secondsPerInterval);
              origin.binnedCounts[intervalIndex] += count;
              group.binnedCounts[intervalIndex] += count;
              binnedCounts[intervalIndex] += count;
              if(0 === origin.groupId) {
                var subGroup = group.arcs[origin.subGroupId];
                subGroup.secondCounts[second] += count;
                subGroup.binnedCounts[intervalIndex] += count
              }
            }
          }
        }
        setTimeout(handleBatch, 15)
      }
      function finalizeGroup(group) {
        group.binMax = Math.max.apply(null, group.binnedCounts);
        var seconds = group.secondCounts;
        var cumulatives = group.cumulativeCounts;
        cumulatives[0] = seconds[0];
        for(var i = 1, L = seconds.length; i < L; i++) {
          cumulatives[i] = cumulatives[i - 1] + seconds[i]
        }
        delete group.secondCounts
      }
      function finalize() {
        var group;
        var total = {
          binnedCounts: binnedCounts,
          cumulativeCounts: []
        };
        var seconds = secondCounts
        , cumulatives = total.cumulativeCounts;
        cumulatives[0] = seconds[0];
        for(var i = 1, L = seconds.length; i < L; i++) {
          cumulatives[i] = cumulatives[i - 1] + seconds[i]
        }
        groups.forEach(finalizeGroup);
        groups[0].arcs.forEach(finalizeGroup);
        var origin, destination, oType, dType, oSubtype, path;
        for(var o = 0, L = requiredPaths.length; o < L; o++) {
          if(!requiredPaths[o]) {
            continue
          }
          origin = centerLookup[o];
          oType = origin.groupId;
          oSubtype = origin.subtype || false;
          for(var d = 0, dL = requiredPaths[o].length; d < dL; d++) {
            if(!requiredPaths[o][d]) {
              continue
            }
            destination = centerLookup[d];
            dType = destination.groupId;
            if(oType == 0) {
              if(dType == 0) {
                if(oSubtype == destination.subtype) {
                  if("Practice Encounter" == oSubtype) {
                    path = new app.BezierPath(origin,destination);
                    var controlData = BEZIER_CONTROLS[path.origin.id];
                    if(controlData) {
                      controlData = controlData[path.destination.id]
                    }
                    path.controlData = controlData || [-0.6283, 0.3, 3.7699, 0.3]
                  } else {
                    path = new app.SuperGroupOuterPath(origin,destination)
                  }
                } else {
                  if("Practice Encounter" == oSubtype || "Practice Encounter" == destination.subtype) {
                    path = new app.SuperGroupIntraRingPath(origin,destination)
                  } else {
                    path = new app.SuperGroupOuterPath(origin,destination)
                  }
                }
              } else {
                if("Practice Encounter" == oSubtype) {
                  path = new app.SuperGroupIntraRingPath(origin,destination)
                } else {
                  path = new app.IntraRingPath(origin,destination)
                }
              }
            } else {
              if(dType == 0) {
                if("Practice Encounter" == destination.subtype) {
                  path = new app.SuperGroupIntraRingPath(origin,destination)
                } else {
                  path = new app.IntraRingPath(origin,destination)
                }
              } else {
                path = new app.OuterPath(origin,destination)
              }
            }
            origin.addPath(path)
          }
        }
        total.binMax = Math.max.apply(null, total.binnedCounts);
        total.name = "Daily Activities";
        dataLoader.announce(constants.DATA_LOAD_EVENT, {
          groups: groups,
          centers: centers,
          centerLookup: centerLookup,
          bursts: bursts,
          total: total,
          ring: ring
        })
      }
      handleBatch()
    }
    function initLerpColors() {
      var lerpColors = []
      , color = F.color
      , lerpColor = color.lerpColor
      , rgb2hsl = color.rgb2hsl
      , hsl2rgb = color.hsl2rgb
      , GROUP_COLORS = constants.GROUP_COLORS
      , GROUP_LERP_COLORS = constants.GROUP_LERP_COLORS
      , GROUP_NAMES = constants.GROUP_NAMES;
      for(var srcName in GROUP_COLORS) {
        var srcRgb = GROUP_COLORS[srcName]
        , srcHsl = rgb2hsl(srcRgb);
        lerpColors[srcName] = {};
        for(var destName in GROUP_LERP_COLORS) {
          var destRgb = GROUP_LERP_COLORS[destName]
          , destHsl = rgb2hsl(destRgb)
          , lerpsteps = [];
          lerpColors[srcName][destName] = lerpsteps;
          for(var l = 0; l < constants.LERP_RANGE; l++) {
            var progress = 1 * l / (constants.LERP_RANGE - 1)
            , hsl = lerpColor(srcHsl, destHsl, progress);
            lerpsteps[l] = hsl2rgb(hsl)
          }
        }
      }
      return lerpColors
    }
    function setLabelTemplate(data) {
      $labelTemplate = data.$nodeLabelTemplate;
      $labelParent = data.$labelParent
    }
    var dataLoader = {
      load: load,
      setLabelTemplate: setLabelTemplate
    };
    F.eventify(dataLoader);
    app.dataLoader = dataLoader
  }
  )(window.app)
})()
